"use strict";(self.webpackChunksmithy4s=self.webpackChunksmithy4s||[]).push([[880],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,y=d["".concat(l,".").concat(u)]||d[u]||c[u]||r;return n?i.createElement(y,o(o({ref:t},m),{},{components:n})):i.createElement(y,o({ref:t},m))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9091:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],s={sidebar_label:"Type refinements",title:"Type refinements"},l=void 0,p={unversionedId:"codegen/customisation/refinements",id:"codegen/customisation/refinements",title:"Type refinements",description:"Type refinements provide a mechanism for using types that you control inside the code generated by smithy4s. Creating a refinement for use in your application starts with creating a custom smithy trait that represents the refinement.",source:"@site/../docs/target/jvm-2.13/mdoc/04-codegen/01-customisation/04-refinements.md",sourceDirName:"04-codegen/01-customisation",slug:"/codegen/customisation/refinements",permalink:"/smithy4s/docs/codegen/customisation/refinements",draft:!1,editUrl:"https://github.com/disneystreaming/smithy4s/edit/main/modules/docs/src/04-codegen/01-customisation/04-refinements.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Type refinements",title:"Type refinements"},sidebar:"tutorialSidebar",previous:{title:"Collections",permalink:"/smithy4s/docs/codegen/customisation/collections"},next:{title:"Unwrapping",permalink:"/smithy4s/docs/codegen/customisation/unwrapping"}},m={},c=[{value:"Parameterised Types",id:"parameterised-types",level:4}],d={toc:c};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Type refinements provide a mechanism for using types that you control inside the code generated by smithy4s. Creating a refinement for use in your application starts with creating a custom smithy trait that represents the refinement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'namespace test\n\n@trait(selector: "string")\nstructure emailFormat {}\n')),(0,r.kt)("p",null,"This trait can now be used on ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," shapes to indicate that they must match an email format."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@emailFormat\nstring Email\n")),(0,r.kt)("p",null,"Now we need to tell smithy4s that we want to represent shapes annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"@emailFormat")," as a custom type that we define."),(0,r.kt)("p",null,"Given a custom email type such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// Note, we recommend using a newtype library over a regular case class in most cases\n// But this is shown to simplify the example\ncase class Email(value: String)\nobject Email {\n\n  private def isValidEmail(value: String): Boolean = ???\n\n  def apply(value: String): Either[String, Email] =\n    if (isValidEmail(value)) Right(new Email(value))\n    else Left("Email is not valid")\n}\n')),(0,r.kt)("p",null,"Next, we will need to provide a way for smithy4s to understand how to construct and deconstruct our ",(0,r.kt)("inlineCode",{parentName:"p"},"Email")," type. We do this by defining an instance of a ",(0,r.kt)("inlineCode",{parentName:"p"},"RefinementProvider"),". Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"RefinementProvider")," we create MUST be ",(0,r.kt)("inlineCode",{parentName:"p"},"implicit"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'// package myapp.types\nimport smithy4s._\n\ncase class Email(value: String)\nobject Email {\n\n  private def isValidEmail(value: String): Boolean = ???\n\n  def apply(value: String): Either[String, Email] =\n    if (isValidEmail(value)) Right(new Email(value))\n    else Left("Email is not valid")\n\n  // highlight-start\n  implicit val provider = Refinement.drivenBy[EmailFormat](\n    Email.apply, // Tells smithy4s how to create an Email (or get an error message) given a string\n    (e: Email) => e.value // Tells smithy4s how to get a string from an Email\n  )\n  // highlight-end\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"EmailFormat")," type passed as a type parameter to ",(0,r.kt)("inlineCode",{parentName:"p"},"Refinement.drivenBy")," is the type that smithy4s generated from our ",(0,r.kt)("inlineCode",{parentName:"p"},"@emailFormat")," trait we defined in our smithy file earlier.")),(0,r.kt)("p",null,"Now, we just have one thing left to do: tell smithy4s where to find our custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Email")," type. We do this using a trait called ",(0,r.kt)("inlineCode",{parentName:"p"},"smithy4s.meta#refinement"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'use smithy4s.meta#refinement\n\napply test#emailFormat @refinement(\n  targetType: "myapp.types.Email"\n)\n')),(0,r.kt)("p",null,"Here we are applying the refinement trait to our ",(0,r.kt)("inlineCode",{parentName:"p"},"emailFormat")," trait we defined earlier. We are providing the ",(0,r.kt)("inlineCode",{parentName:"p"},"targetType")," which is our ",(0,r.kt)("inlineCode",{parentName:"p"},"Email")," case class we defined."),(0,r.kt)("p",null,"Smithy4s will now be able to update how it does code generation to reference our custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Email")," type."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If the provider was not in the companion object of our ",(0,r.kt)("inlineCode",{parentName:"p"},"targetType"),", we would need to provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"providerImport")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"refinement")," trait\nso that smithy4s would be able to find it. For example:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'use smithy4s.meta#refinement\n\napply test#emailFormat @refinement(\n  targetType: "myapp.types.Email",\n  providerImport: "myapp.types.providers._"\n)\n')),(0,r.kt)("p",{parentName:"admonition"},"Whether the provider is in the companion object or not, it must be ",(0,r.kt)("inlineCode",{parentName:"p"},"implicit"),".")),(0,r.kt)("h4",{id:"parameterised-types"},"Parameterised Types"),(0,r.kt)("p",null,"As of smithy4s version 0.17, you can now create refinements on types that take a generic type parameter. This can be accomplished by setting ",(0,r.kt)("inlineCode",{parentName:"p"},"parameterised")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," as seen below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@trait(selector: "list")\n@refinement(\n  targetType: "smithy4s.example.refined.NonEmptyList",\n  parameterised: true\n)\nstructure nonEmptyListFormat {}\n')),(0,r.kt)("p",null,"Following this, we now need to create our refinement provider as we did with the example above. In this case, we will use an implicit function so we can reference the generic type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),". This allows us to use the same implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList")," across lists containing any type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import smithy4s._\n\ncase class NonEmptyList[A] private (values: List[A])\n\nobject NonEmptyList {\n\n  def apply[A](values: List[A]): Either[String, NonEmptyList[A]] =\n    if (values.size > 0) Right(new NonEmptyList(values))\n    else Left("List must not be empty.")\n\n  implicit def provider[A] = Refinement.drivenBy[NonEmptyListFormat](\n    NonEmptyList.apply[A],\n    (b: NonEmptyList[A]) => b.values\n  )\n}\n')),(0,r.kt)("p",null,"Now we can apply our ",(0,r.kt)("inlineCode",{parentName:"p"},"nonEmptyListFormat")," trait as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@nonEmptyListFormat\nlist NonEmptyStrings {\n  member: String\n}\n")),(0,r.kt)("p",null,"In the generated Scala code, this will render as a ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList[String]")," instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"List[String]"),". Similarly, we can apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"nonEmptyListFormat")," trait to any ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," shape and it will render as a ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),". This works for all shapes that can be specified as list members including primitives, structures, collections, and even other refined types."))}u.isMDXComponent=!0}}]);