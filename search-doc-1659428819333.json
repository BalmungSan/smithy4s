[{"title":"Intro","type":0,"sectionRef":"#","url":"docs/overview/intro","content":"Intro Smithy is an interface definition language (IDL) provided by AWS. It is protocol agnostic, flexible, and reasonably low surface, which facilitates the writing of tooling around it. Smithy4s is a tool that generates third-party-free, protocol-agnostic scala code from smithy specifications. Smithy4s can be used to: quickly derive http/rest servers and clientsderive pure-scala AWS clientsderive CLI toolsand has the potential for much, much more!","keywords":""},{"title":"Installation (SBT)","type":0,"sectionRef":"#","url":"docs/overview/sbt","content":"Installation (SBT) smithy4s-sbt-codegen is a code generating sbt plugin that creates .scala files corresponding to the provided .smithy specs. The generated code includes traits for any services you might define, as well as case classes for models used in these services. It has no dependencies on external libraries or any specific protocol like HTTP or JSON. It does, however, depend on a &quot;core&quot; library that contains a number of interfaces implemented by the generated code. In project/plugins.sbt: addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.14.2&quot;) Copy and enable the plugin in the desired sbt module: import smithy4s.codegen.Smithy4sCodegenPlugin val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) // version for smithy4s-core is sourced from Smithy4sCodegenPlugin .settings(libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value) Copy This will enable the plugin on myModule. We also need to add smithy4s-core here since it is needed for compiling the generated code. By default, the plugin will look in the $MY_MODULE/src/main/smithy directory and will write scala code in $MY_MODULE/target/scala-&lt;version&gt;/src_managed/ when invoking compile. The paths are configurable via the smithy4sInputDir and smithy4sOutputDir settings keys. For example, in order for the plugin to source .smithy specs from ./smithy_input (inside the folder where our build.sbt is) and output the generated files into ./smithy_output. val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( scalaVersion := &quot;2.13.8&quot;, smithy4sInputDir in Compile := (baseDirectory in ThisBuild).value / &quot;smithy_input&quot;, smithy4sOutputDir in Compile := (baseDirectory in ThisBuild).value / &quot;smithy_output&quot;, libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value ) Copy","keywords":""},{"title":"General design principles","type":0,"sectionRef":"#","url":"docs/design/design","content":"General design principles Before we dive in to the design elements, it is important to state that Smithy4s is designed with the following constraints : optimised for number of usecases: Smithy4s is not (just) an http/json library, it can/could be used for a great many things, such as AWS SDKs, CLIs, UIs, etc. Therefore, following the protocol-agnostic nature of smithy, the code generated by Smithy4s is not biased towards any protocol or serialisation mechanism, nor any runtime or Scala version.optimised for correctness over compatibility: there is strictly no guarantee made regarding backward compatibility of the generated code when users evolve their smithy schemas. Therefore, users are expected to regenerate the code at use-site, instead of relying on artifacts that would contain the generated code... However, users do get idiomatic Scala code, including case classes / sealed traits (which are notoriously hard to evolve in binary compatible ways), and this generated code correctly reflects the smithy specifications.decoupled from third-party libraries: the generated code depends only on smithy4s-core for compilation, which does not pull third-party dependencies (not even a general purpose libraries that the maintainers love, like cats) These constraints may sound counter-intuitive, obtuse, even alien. The internals of this library are not beginner friendly. They rely on advanced features of the Scala compiler that may unfortunately scare away newcomers interested in contributing. If you're not discouraged yet, do not hesitate to ask questions using github discussions, we will do our best to answer them!","keywords":""},{"title":"Sharing specifications","type":0,"sectionRef":"#","url":"docs/overview/sharing-specs","content":"","keywords":""},{"title":"SBT​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#sbt","content":"Using the SBT plugin, the Smithy4s config object can be used to tag dependencies that Smithy4s should feed to the code generator. For instance, AWS publishes a number of api-gateway specific traits to Maven central (the shapes are defined there in a smithy-compliant Json file). You can declare your intent to depend on these smithy definitions as such : libraryDependencies += &quot;software.amazon.smithy&quot; % &quot;smithy-aws-iam-traits&quot; % &quot;1.14.1&quot; % Smithy4s Copy This will have the effect of loading the contents of the smithy files (or smithy-compliant Json files) from the artifact into the aggregated model that Smithy4s uses as an input to the code generator. It means that the traits and shapes defined in these files will be available to use in your models, but it also means that Smithy4s will try to generate code for these shapes. It sometimes happens that Scala code reflecting these shapes was already generated and made available to another module or artifact. In that case, you can gain control over which namespaces Smithy4s crawls through when performing the code generation to avoid regenerating code that already exists. This is achieved via a couple of SBT settings : smithy4sAllowedNamespaces which is an allow-listsmithy4sExcludedNamespaces which is a disallow-list By default, Smithy4s tries to generate everything but shapes that are in the following namespaces : smithy4s.apismithy4s.metanamespaces that start with awsnamespaces that start with smithy "},{"title":"Note regarding credentials​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#note-regarding-credentials","content":"The SBT plugin provided by Smithy4s uses SBT's resolution mechanism (based on coursier) to retrieve the artifacts from their respective repositories. This implies that the resolvers-related settings are respected, included credentials that may be needed to read from some private artifact repository. In the CLI, the mechanisms native to coursier are respected. "},{"title":"Packaging specifications in order to share them​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#packaging-specifications-in-order-to-share-them","content":"Smithy4s does not have any features that help in the packaging of specifications. This is a design decision that can be explained by the fact that Smithy4s optimises for &quot;correctness&quot; as opposed to &quot;compatibility.&quot; This means the generated Scala code aims at 1) being an accurate reflection of the Smithy models and 2) providing an idiomatic developer experience. This happens at the cost of a total lack of guarantees around the binary compatibility of the generated code when the Schema evolves. Therefore, we recommend that you DO NOT treat the generated code as publishable library-material. Additionally, the inlined smithy files that you may have under src/main/smithy are not packaged as resources by Smithy4s. However, if you want to package specifications in jars and publish them to an artifact repository so that several codebases may benefit from it (via Smithy4s or other tools), it is really simple: All smithy files should be stored under src/main/resources/META-INF/smithy/ (or in another resource directory, under META-INF/smithy)A manifest file should be stored under that same directoryThe manifest file should reference all the smithy files that can be found in that META-INF/smithy directory. A couple examples : smithy-aws-apigateway-traitssmithy4s-protocols "},{"title":"Customisation","type":0,"sectionRef":"#","url":"docs/codegen/customisation","content":"Customisation Smithy4s is opinionated in what the generated code look like, there are a few things that can be tweaked. Packed inputs​ By default, Smithy4s generates methods the parameters of which map to the fields of the input structure of the corresponding operation. For instance : service PackedInputsService { version: &quot;1.0.0&quot;, operations: [PackedInputOperation] } operation PackedInputOperation { input: PackedInput, } structure PackedInput { @required a: String, @required b: String } Copy leads to something conceptually equivalent to : trait PackedInputServiceGen[F[_]] { def packedInputOperation(a: String, b: String) : F[Unit] } Copy It is however possible to annotate the service (or operation) definition with the smithy4s.meta#packedInputs trait, in order for the rendered method to contain a single parameter, typed with actual input case class of the operation. For instance : use smithy4s.meta#packedInputs @packedInputs service PackedInputsService { version: &quot;1.0.0&quot;, operations: [PackedInputOperation] } Copy will produce the following Scala code trait PackedInputServiceGen[F[_]] { def packedInputOperation(input: PackedInput) : F[Unit] } Copy ADT Member Trait​ The default behavior of Smithy4s when rendering unions that target structures is to render the structure in a separate file from the union that targets it. This makes sense if the structure is used in other contexts other than the union. However, it also causes an extra level of nesting within the union. This is because the union will create another case class to contain your structure case class. For example: union OrderType { inStore: InStoreOrder } structure InStoreOrder { @required id: OrderNumber, locationId: String } Copy Would render the following scala code: OrderType.scala: sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreCase(inStore: InStoreOrder) extends OrderType Copy InStoreOrder.scala: case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None) Copy The sealed hierarchy OrderType has a member named InStoreCase. This is becauseInStoreOrder is rendered in a separate file and OrderType is sealed. However, adding the adtMember trait to the InStoreOrder structure changes this. union OrderType { inStore: InStoreOrder } @adtMember(OrderType) // added the adtMember trait here structure InStoreOrder { @required id: OrderNumber, locationId: String } Copy sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None) extends OrderType Copy The IsStoreOrder class has now been updated to be rendered directly as a member of the OrderTypesealed hierarchy. The adtMember trait can be applied to any structure as long as said structure is targeted by EXACTLY ONE union.This means it must be targeted by the union that is provided as parameter to the adtMember trait. This constraint is fulfilled above because OrderType targets InStoreOrder and InStoreOrder is annotated with @adtMember(OrderType). The structure annotated with adtMember (e.g. InStoreOrder) also must not be targeted by any other structures or unions in the model. There is a validator that will make sure these requirements are met whenever the adtMember trait is in use. Note: The adtMember trait has NO impact on the serialization/deserialization behaviors of Smithy4s. The only thing it changes is what the generated code looks like. This is accomplished by keeping the rendered schemas equivalent, even if the case class is rendered in a different place. Specialized collection types​ Smithy supports list and set, Smithy4s renders that to List[A] and Set[A] respectively. You can also use the @uniqueItems annotation on list which is equivalent to set. Smithy4s has support for two specialized collection types: Vector and IndexedSeq. The following examples show how to use them: use smithy4s.meta#indexedSeq use smithy4s.meta#vector @indexedSeq list SomeIndexSeq { member: String } @vector list SomeVector { member: String } Copy Both annotations are only applicable on list shapes. You can't mix @vector with @indexedSeq, and neither one can be used with @uniqueItems.","keywords":""},{"title":"Unions and sealed traits","type":0,"sectionRef":"#","url":"docs/codegen/unions","content":"","keywords":""},{"title":"Flattening of structure members​","type":1,"pageTitle":"Unions and sealed traits","url":"docs/codegen/unions#flattening-of-structure-members","content":"Under certain conditions, Smithy4s offers a mechanism to &quot;flatten&quot; structure members directly as a member of the sealed trait. Head over to the page explaining code-gen customisation for a detailed explanation. "},{"title":"Regarding JSON encoding​","type":1,"pageTitle":"Unions and sealed traits","url":"docs/codegen/unions#regarding-json-encoding","content":"Smithy4s does not rely on the classic automated derivation mechanisms to determine how unions should be encoded in JSON. Rather, the Smithy models dictates the encoding. Indeed, there are multiple ways to encode unions in JSON. By default, the specification of the Smithy language hints that the tagged-union encoding should be used. This is arguably the best encoding for unions, as it works with members of any type (not just structures), and does not require backtracking during parsing, which makes it more efficient. However, Smithy4s provides support for two additional encodings: discriminated and untagged, which users can opt-in via the smithy4s.api#discriminated and smithy4s.api#untagged trait, respectively. These are mostly offered as a way to retrofit existing APIs in Smithy. Tagged union​ This is the default behaviour, and happens to visually match how Smithy unions are declared. In this encoding, the union is encoded as a JSON object with a single key-value pair, the key signalling which alternative has been encoded. union Tagged { first: String, second: IntWrapper } structure IntWrapper { int: Integer } Copy The following instances of Tagged Tagged.FirstCase(&quot;smithy4s&quot;) Tagged.SecondCase(IntWrapper(42))) Copy are encoded as such : { &quot;first&quot;: &quot;smithy4s&quot; } { &quot;second&quot;: { &quot;int&quot;: 42 } } Copy Untagged union​ Untagged unions are supported via an annotation: @untagged. Despite the smaller payload size this encoding produces, it is arguably the worst way of encoding unions, as it may require backtracking multiple times on the parsing side. Use this carefully, preferably only when you need to retrofit an existing API into Smithy use smithy4s.api#untagged @untagged union Untagged { first: String, second: IntWrapper } structure IntWrapper { int: Integer } Copy The following instances of Untagged Untagged.FirstCase(&quot;smithy4s&quot;) Untagged.SecondCase(Two(42))) Copy are encoded as such : &quot;smithy4s&quot; { &quot;int&quot;: 42 } Copy Discriminated union​ Discriminated union are supported via an annotation: @discriminated(&quot;tpe&quot;), and work only when all members of the union are structures. In this encoding, the discriminator is inlined as a JSON field within JSON object resulting from the encoding of the member. Despite the JSON payload exhibiting less nesting than in the tagged union encoding, this encoding often leads to bigger payloads, and requires backtracking once during parsing. use smithy4s.api#discriminated @discriminated(&quot;tpe&quot;) union Discriminated { first: StringWrapper, second: IntWrapper } structure StringWrapper { string: String } structure IntWrapper { int: Integer } Copy The following instances of Discriminated Discriminated.FirstCase(StringWrapper(&quot;smithy4s&quot;)) Discriminated.SecondCase(IntWrapper(42))) Copy are encoded as such { &quot;tpe&quot;: &quot;first&quot;, &quot;string&quot;: &quot;smithy4s&quot; } { &quot;tpe&quot;: &quot;second&quot;, &quot;int&quot;: 42 } Copy "},{"title":"Protocols and Smithy4s","type":0,"sectionRef":"#","url":"docs/protocols/protocols","content":"Protocols and Smithy4s The code generated by Smithy4s is strictly protocol agnostic, meaning that there is no particular processing to handle HTTP semantics, or JSON semantics in the generated code. Instead, Smithy4s relies on a number of highly polymorphic interfaces to communicate with the generated code, and derive JSON codecs out of it, or turn high level user provided code into HTTP services. But in theory, the same generated code can be used conjointly with other serialisation technologies (protobuf for instance) and protocols (gRPC). Protocol specific &quot;hints&quot; (called traits)can be added to the smithy models. Smithy4s accurately renders corresponding values, and allows for their retrieval via the polymorphic interfaces. This is how HTTP semantics can be derived from the generated code, for instance. Smithy4s is also not tied to any third-party library, and users could provide integrations with existing libraries on their own side, or come up with new interesting usecases. However, Smithy4s provides a few out-of-the-box integrations that are described in this section.","keywords":""},{"title":"SimpleRestJson client","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/client","content":"SimpleRestJson client The smithy4s-http4s module provides functions that transform low-level http4s clients into high-level stubs, provided the corresponding service definitions (in smithy) are annotated with the simpleRestJson protocol. In build.sbt libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s&quot; % smithy4sVersion.value ) Copy In Clients.scala import smithy4s.http4s._ import org.http4s.Uri import org.http4s.client.Client import cats.effect.IO import cats.effect.Resource // the package under which the scala code was generated import smithy4s.hello._ object Clients { def helloWorldClient(http4sClient: Client[IO]) : Resource[IO, HelloWorldService[IO]] = HelloWorldService.simpleRestJson.clientResource( http4sClient, Uri.unsafeFromString(&quot;http://localhost&quot;) ) // alternatively ... def helloWorldClient2(http4sClient: Client[IO]) : Resource[IO, HelloWorldService[IO]] = SimpleRestJsonBuilder(HelloWorldService).clientResource( http4sClient, Uri.unsafeFromString(&quot;http://localhost&quot;) ) } Copy","keywords":""},{"title":"aws","type":0,"sectionRef":"#","url":"docs/protocols/aws/aws","content":"aws WARNING: THIS IS EXPERIMENTAL, DO NOT NOT EXPECT PRODUCTION READINESS Smithy4s provides functions to create AWS clients from generated code. At the time of writing this, smithy4s is only able to derive clients for AWS services that use the AWS Json 1.0/1.1 protocol. The AWS smithy specs (that are written in json syntax) can be found in some of the official SDKs published by AWS. These .json files can be understood by smithy4s, just like .smithy, and can be used to generate code. Just copy/paste them in your project. We (the Smithy4s maintainers) do not intend to publish pre-generated artifacts containing the AWS clients, there's a lot of nuance there and maintainance burden that we do not have the capacity to assume. In particular, backward binary compatibility of the generated code is impossible to guarantee at this time. Setup​ In build.sbt libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-aws-http4s&quot; % smithy4sVersion.value ) Copy In your Scala code: import cats.effect._ import org.http4s.ember.client.EmberClientBuilder import smithy4s.aws._ // AWS models and cats-effect/fs2 specific functions // AWS models and cats-effect/fs2 specific functions import smithy4s.aws.http4s._ // AWS/http4s specific integration // AWS/http4s specific integration import com.amazonaws.dynamodb._ // Generated code from specs. // Generated code from specs. object Main extends IOApp.Simple { def run = resource.use { dynamodb =&gt; dynamodb .describeTable(TableName(&quot;omelois-test&quot;)) .run .flatMap(IO.println(_)) } val resource: Resource[IO, AwsClient[DynamoDBGen, IO]] = for { httpClient &lt;- EmberClientBuilder.default[IO].build dynamodb &lt;- DynamoDB.awsClient(httpClient, AwsRegion.US_EAST_1) } yield dynamodb } Copy","keywords":""},{"title":"Quick Start","type":0,"sectionRef":"#","url":"docs/overview/quickstart","content":"","keywords":""},{"title":"project/plugins.sbt​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#projectpluginssbt","content":"Add the smithy4s-sbt-codegen plugin to your build. addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.14.2&quot;) Copy "},{"title":"build.sbt​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#buildsbt","content":"Enable the plugin in your project, add the smithy and http4s dependencies. import smithy4s.codegen.Smithy4sCodegenPlugin ThisBuild / scalaVersion := &quot;2.13.8&quot; val example = project .in(file(&quot;modules/example&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( libraryDependencies ++= Seq( &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s&quot; % smithy4sVersion.value, &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s-swagger&quot; % smithy4sVersion.value, &quot;org.http4s&quot; %% &quot;http4s-ember-server&quot; % &quot;0.23.14&quot; ) ) Copy "},{"title":"modules/example/src/main/smithy/ExampleService.smithy​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#modulesexamplesrcmainsmithyexampleservicesmithy","content":"Define your API in smithy files. namespace smithy4s.hello use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String } Copy The Scala code corresponding to this smithy file will be generated the next time you compile your project. "},{"title":"modules/example/src/main/scala/Main.scala​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#modulesexamplesrcmainscalamainscala","content":"Implement your service by extending the generated Service trait. Wire up routes into server. import smithy4s.hello._ import cats.effect._ import cats.implicits._ import org.http4s.implicits._ import org.http4s.ember.server._ import org.http4s._ import com.comcast.ip4s._ import smithy4s.http4s.SimpleRestJsonBuilder object HelloWorldImpl extends HelloWorldService[IO] { def hello(name: String, town: Option[String]) : IO[Greeting] = IO.pure { town match { case None =&gt; Greeting(s&quot;Hello $name!&quot;) case Some(t) =&gt; Greeting(s&quot;Hello $name from $t!&quot;) } } } object Routes { private val example: Resource[IO, HttpRoutes[IO]] = SimpleRestJsonBuilder.routes(HelloWorldImpl).resource private val docs: HttpRoutes[IO] = smithy4s.http4s.swagger.docs[IO](HelloWorldService) val all: Resource[IO, HttpRoutes[IO]] = example.map(_ &lt;+&gt; docs) } object Main extends IOApp.Simple { val run = Routes.all .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build } .use(_ =&gt; IO.never) } Copy "},{"title":"Run Service​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#run-service","content":"sbt &quot;example/run&quot; Copy "},{"title":"Navigate to localhost:9000/docs​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#navigate-to-localhost9000docs","content":"Here you will find the automatically generated SwaggerUI which will allow you to easily test your API.   "},{"title":"Client Example​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#client-example","content":"You can also generate a client using smithy4s. import org.http4s.ember.client.EmberClientBuilder object ClientImpl extends IOApp.Simple { val helloWorldClient: Resource[IO, HelloWorldService[IO]] = for { client &lt;- EmberClientBuilder.default[IO].build helloClient &lt;- SimpleRestJsonBuilder(HelloWorldService).clientResource( client, Uri.unsafeFromString(&quot;http://localhost:9000&quot;) ) } yield helloClient val run = helloWorldClient.use(c =&gt; c.hello(&quot;Sam&quot;, Some(&quot;New York City&quot;)) .flatMap(greeting =&gt; IO.println(greeting.message)) ) } Copy "},{"title":"The SimpleRestJson protocol","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/overview","content":"","keywords":""},{"title":"Semantics​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#semantics","content":"In this protocol, the values in shapes are bound to http metadata or body according to the specification of the Http Binding traits. However, the @mediaType trait has no incidence, and all bodies (when present) are serialised in JSON. "},{"title":"Example spec​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#example-spec","content":"namespace smithy4s.example use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, // Indicates that all operations in `HelloWorldService`, // here limited to the Hello operation, can return `GenericServerError`. errors: [GenericServerError], operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String } Copy "},{"title":"Supported taits​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#supported-taits","content":"This protocol and its interpreters, are aware of the following traits provided out of the box: all simple shapescomposite data shapes, including collections, unions, structures.operations and servicesenumerationserror traithttp traits, including http, httpError, httpLabel, httpHeader, httpPayload, httpQuery, httpPrefixHeaders, httpQueryParams.timestampFormat trait "},{"title":"Decoding and encoding unions​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#decoding-and-encoding-unions","content":"The SimpleRestJson protocol supports 3 different union encodings : tagged (default)untaggeddiscriminated See the section about unions for a detailed description. "},{"title":"Installation (CLI)","type":0,"sectionRef":"#","url":"docs/overview/cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Installation (CLI)","url":"docs/overview/cli#installation","content":"cs install --channel https://disneystreaming.github.io/coursier.json smithy4s Copy "},{"title":"Usage​","type":1,"pageTitle":"Installation (CLI)","url":"docs/overview/cli#usage","content":"The CLI comes with a number of options to customize output directories, skip openapi generation (or scala generation), provide a filter of allowed namespaces, etc. Use the --help command to get an exhaustive listing. bash&gt; smithy4s --help Usage: smithy4s generate smithy4s dump-model Command line interface for Smithy4s Options and flags: --help Display this help text. Subcommands: generate Generates scala code and openapi-specs from smithy specs dump-model Output a JSON view of the Smithy models Copy Codegen​ bash&gt; smithy4s generate --help Usage: generate [--output &lt;path&gt;] [--openapi-output &lt;path&gt;] [--skip-scala] [--skip-openapi] [--discover-models] [--allowed-ns &lt;string,string,...&gt;] [--excluded-ns &lt;string,string,...&gt;] [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--localJars &lt;path,path,...&gt;] [&lt;path&gt;...] Generates scala code and openapi-specs from smithy specs Options and flags: --help Display this help text. --output &lt;path&gt;, -o &lt;path&gt; Path where scala code should be generated. Defaults to pwd --openapi-output &lt;path&gt; Path where openapi should be generated. Defaults to pwd --skip-scala Indicates that scala code generation should be skipped --skip-openapi Indicates that openapi specs generation should be skipped --discover-models Indicates whether the model assembler should try to discover models in the classpath --allowed-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --excluded-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --localJars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files Copy Dump model​ bash&gt; smithy4s dump-model --help Usage: dump-model [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--localJars &lt;path,path,...&gt;] [&lt;path&gt;...] Output a JSON view of the Smithy models Options and flags: --help Display this help text. --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --localJars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files Copy "},{"title":"Openapi","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/openapi","content":"","keywords":""},{"title":"Swagger UI​","type":1,"pageTitle":"Openapi","url":"docs/protocols/simple-rest-json/openapi#swagger-ui","content":"When you visit your documentation page, you'll be served with a Swagger UI application that looks like this:  If your documentation route supports multiple service, the dropdown in the top bar (top right) should allow you to select other specifications:  "},{"title":"SimpleRestJson server","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/server","content":"","keywords":""},{"title":"A note about errors​","type":1,"pageTitle":"SimpleRestJson server","url":"docs/protocols/simple-rest-json/server#a-note-about-errors","content":"When encountering data types annotated with the @error trait in smithy, smithy4s will ensure that the generated types extend Throwable. The interpreters are aware of it, and try to recover any error raised in your effect-types that your smithy specs know about, in order to render it correctly in Json and apply the specified status code (see the @httpError trait for this). As a convenience, Smithy4s provides mapErrors and flatMapErrors methods, that allow to intercept exceptions that were not specified in the spec, and transform them into exceptions that were. In particular, the smithy4s interpreters raise specific errors when they fail to decode http requests. The mapErrors and flatMapErrors methods can be used to ensure that a specified error is returned by your service: myRoutes.mapErrors{ case e : PayloadError =&gt; MyClientError(...) }.resource Copy "},{"title":"Wiring the routes​","type":1,"pageTitle":"SimpleRestJson server","url":"docs/protocols/simple-rest-json/server#wiring-the-routes","content":"As a reminder, to wire those routes into a server, you need something like: import cats.effect._ import org.http4s.ember.server._ import org.http4s.implicits._ import com.comcast.ip4s._ object Main extends IOApp { def run(args: List[String]): IO[ExitCode] = Routes.myRoutes.flatMap { routes =&gt; EmberServerBuilder.default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build }.use(_ =&gt; IO.never) .as(ExitCode.Success) } Copy "},{"title":"Datatypes and schemas","type":0,"sectionRef":"#","url":"docs/design/schemas","content":"","keywords":""},{"title":"The Schema GADT​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#the-schema-gadt","content":"Each datatype generated by Smithy4s is accompanied by a schema value in its companion object, which contains an expression of type smithy4s.schema.Schema that captures everything needed to deconstruct/reconstruct instances of the datatype. smithy4s.schema.Schema is a Generalised Algebraic Datatype (or GADT for short) that can be used to precisely reference all the information needed to traverse datatypes that can be expressed in Smithy. It is a bit like JVM reflection, except that it exposes higher-level information about the datatypes. It achieves this by exposing building blocks that accurately reflect what is possible to express in the Smithy language. These building blocks form a metamodel: a model for models. And, unlike JVM reflection, using schemas is type-safe. The Schema type reflects the various ways of constructing datatypes in Smithy. It is encoded as a sealed trait, the members of which capture the following aspects of the Smithy language: PrimitivesListsSetsMapsEnumerationsStructuresUnions For a Scala type called Foo, formulating a Schema[Foo] is equivalent to exhaustively capturing the information needed for the serialisation and deserialisation of Foo in any format (JSON, XML, ...). Indeed, for any Codec[_] construct provided by third-party libraries, it is possible to write a generic def compile(schema: Schema[A]): Codec[A] function that produces the Codec for A based on the information held by the Schema. Why do things this way? Why not just render Codec during code generation? The reason is that we want for the generated code to be completely decoupled from any serialisation format or library, and for the user to have the ability to wire that generated code in different ways, without having to change anything in the build. Moreover, this approach has proven that it allows for a bounded investment for adding interop with various libraries, and offers really good testability. "},{"title":"Hints​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#hints","content":"In Smithy, all shapes (and members of composite shapes) can be annotated with traits. Smithy4s generically translates these annotations to instances of the corresponding generated classes, which means that Smithy4s supports generating user defined traits that it has zero knowledge of. So if you have the following Smithy description: namespace example @trait structure metadata { @required description: String } @metadata(description: &quot;This is my own integer shape&quot;) integer MyInt Copy When processing this Smithy model, Smithy4s renders a case class Metadata(description: String), with an assocaited ShapeTag[Metadata] instance, and the following expression in the companion object of MyInt: val hints = Hints( Metadata(&quot;this is my own integer shape&quot;) ) Copy The smithy4s.Hints type is a polymorphic map that can hold shapes, keyed by ShapeTag. A ShapeTag is a uniquely identified tag that uses referential equality. Every schema can hold a Hints instance, which means that in addition to the datatype structures, Schemas also offer an accurate reflection of the trait values that annotate shapes in the smithy models. Smithy4s uses these hints to implement interpreters. For instance, the smithy.api#jsonName smithy trait translates to a smithy.api.JsonName Scala type, that we can query from a Hints instance when implementing a Schema ~&gt; JsonCodec transformation. This allows to give users a little customisability in the json serialisation of their datatypes. "},{"title":"Structures​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#structures","content":"A structure, also referred to as product, or record, is a construct that groups several values together. Typically, it translates naturally to a case class. namespace example structure Foo { @required a: Integer, @length(min: 1) b: String, } Copy ...and the associated, generated Scala code: package example import smithy4s.schema.Schema._ case class Foo(a: Int, b: Option[String] = None) object Foo extends smithy4s.ShapeTag.Companion[Foo] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;Foo&quot;) implicit val schema: smithy4s.Schema[Foo] = struct( int.required[Foo](&quot;a&quot;, _.a), string.optional[Foo](&quot;b&quot;, _.b).addHints(smithy.api.Length(Some(1), None)) ){ Foo.apply }.withId(id) } Copy As you can see, the Smithy structure translates quite naturally to a Scala case class. Every member of the structure that does not have the @required trait is rendered as an optional value defaulting to None (by default, smithy4s sorts the fields before rendering the case class so that the required ones appear before the optional ones. That is a pragmatic decision that tends to improve UX for users.) Indeed, for each field, there is an associated reference to a schema (int, string, ...), a string label, and a lambda calling the case class accessor that allows the retrieval of the associated field value. Additionally, the constructor of the case class is also referenced in the Schema. Typically, the accessors are needed for encoding the data, which involves destructuring it to access its individual components. The labels are there to cater to serialisation mechanisms like JSON or XML, where sub-components of a piece of data are labelled and nested under a larger block. Conversely, the constructor is used for deserialisation, which involves reconstructing the data after all of its component values have been successfully deserialised. Another detail is the presence of the addHints call on field labelled with b. This is due to the presence of the length trait (from the smithy.api namespace, aka the prelude) on the corresponding b member of the smithy Foo shape. Note related to optional and required​ You may have noticed the required and optional methods, which create Field instances from Schemas, in order to pass them to structures. In Smithy4s, the concept of Option only exists relatively to struct calls. It is not possible to construct a Schema[Option[A]] on its own. The rationale is that having a first class Option schema constructor leads to leaks in the implementation of serialisation mechanisms, as None typically represents the absence of value, and allowing for serialising an absence of value in formats that typically do not support it implies the leak of Option (or equivalent) in various interfaces. Additionally, a first class Option schema constructor would allow to create schemas for Option[Option[Option[Int]]], and even though we recognise that there are some things that could be encoded this way, it is just not a very pragmatic possibility, and opens the door for easy violation of round-trip properties that any serialisation technology should respect. For instance: Some(None) and None can easily have the same encoding in Json, so how do you distinguish between the two during decoding? "},{"title":"Unions​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#unions","content":"Union, also referred to as coproduct, or sum type, is a construct that expresses sealed polymorphism. It is the dual of a structure: when structures express that you have A AND B, unions express that you can have A OR B. The way this is expressed in Smithy looks like this: namespace example union Bar { a: Integer, b: String } Copy This hints at the default serialisation that AWS has intended to use on unions expressed in smithy, namely tagged unions. Indeed, the AWS json-centric protocols specifies that shapes like these should be serialised in objects with a single key/value entry, where the key receives the value of the tag. For instance, { &quot;a&quot; : 1 } or { &quot;b&quot; : &quot;two&quot; }. There are some very relevant technical reasons for it, but this way of encoding unions/co-products in JSON is arguably the best. It may also be familiar to Circe users as it's the default encoding of co-products in circe-generic. Regarding the Scala code rendered by Smithy4s for the above Smithy specification, it looks like this: package example import smithy4s.schema.Schema._ sealed trait Bar extends scala.Product with scala.Serializable object Bar extends smithy4s.ShapeTag.Companion[Bar] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;Bar&quot;) case class ACase(a: Int) extends Bar case class BCase(b: String) extends Bar object ACase { val hints : smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[ACase] = bijection(int.addHints(hints), ACase(_), _.a) val alt = schema.oneOf[Bar](&quot;a&quot;) } object BCase { val hints : smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[BCase] = bijection(string.addHints(hints), BCase(_), _.b) val alt = schema.oneOf[Bar](&quot;b&quot;) } implicit val schema: smithy4s.Schema[Bar] = union( ACase.alt, BCase.alt, ){ case c : ACase =&gt; ACase.alt(c) case c : BCase =&gt; BCase.alt(c) }.withId(id) } Copy The union is rendered as an ADT (sealed trait), the members of which are single-value case classes wrapping values of the types referenced by the union member. The Case suffix is added as a way to reduce risk of collision between the generated code and other types (especially the types being wrapped). Each ADT member is accompanied by its own schema, which is not provided implicitly, in an effort to retain coherence in the type-class instances, and avoid the situation where you'd have different behaviours during serialisation based on whether you've up-casted a member to the ADT. Additionally, the companion objects of each ADT members contain an alt value (for &quot;alternative&quot;), which is the union's equivalent to the structure's field. Much like a field, an alt contains a label, and can carry hints. But unlike a field, which contains an accessor, the alt contains the function to &quot;inject&quot; (up-cast) the member into the union. This is useful for de-serialisation, when, after successfully de-serialising a member of a union, you need to inject it into the ADT to return the expected type. As for the union's schema, it is somewhat similar to the structure's, in that it references all its alternatives. But instead of a structure's constructor, we have a dispatch function instead, which contains a pattern match against all the possible members, and dispatches the &quot;down-casted&quot; value to its corresponding alternative. This is useful for serialisation, when the behaviour of the alternatives can only be applied to values of the corresponding type: &quot;if my ADT is an A, then I serialise the A, and add a discriminating tag to the serialised A&quot;. "},{"title":"Named simple shapes​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#named-simple-shapes","content":"Smithy allows for the creation of named shapes that reference &quot;primitive types&quot;: namespace example integer MyInt Copy Smithy4s translates this to a Scala newtype : a zero-overhead wrapper for the underling type (in this case, Int): package example object MyInt extends Newtype[Int] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;MyInt&quot;) val hints : smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema : smithy4s.Schema[Int] = int.withId(id).addHints(hints) implicit val schema : smithy4s.Schema[MyInt] = bijection(underlyingSchema, MyInt(_), (_ : MyInt).value) } Copy A MyInt type alias, pointing to the MyInt.Type type member, is rendered in the example package object, which makes it possible to write such code: val myInt: MyInt = MyInt(1) // val int: Int = myInt // doesn't compile because MyInt is not an Int at compile time. val int: Int = myInt.value Copy You may have noticed that the schema value is using bijection. Additionally to the GADT members stated previously, Schema also has a BijectionSchema member, which allows to apply bidirectional transformation on other Schemas. This is useful for the case of newtypes: if we are able to derive a codec that can encode and decode Int, it should be possible to derive a codec that encodes and decodes MyInt. "},{"title":"Collections​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#collections","content":"Smithy supports three types of collections out of the box : set (bound to disappear in smithy 2.0 in favour of the @uniqueItems trait)listmap Additionally, Smithy4s allows users to annotate list shapes to customise the type of collection used during code-generation. Smithy does not support generics, therefore all collection are named. Though seemingly tedious, it makes it easier to build tooling (and probably helps languages that do not support generics). Provided the following shape : namespace example list IntList { member: Integer } Copy You get the following Scala code : package example object IntList extends Newtype[List[Int]] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;IntList&quot;) val hints : smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema : smithy4s.Schema[List[Int]] = list(int).withId(id).addHints(hints) implicit val schema : smithy4s.Schema[IntList] = bijection(underlyingSchema, IntList(_), (_ : IntList).value) } Copy It is really similar to named primitives. However, for pragmatic reasons, when a structure references a collection in one of its members, the Scala field gets rendered using the de-aliased type (as opposed to the newtype). The IntList newtype is generated mostly as a way to hold the hints and schemas corresponding to the smithy IntList shape. Additionally, the IntList newtype is used by Smithy4s to render Hints values : namespace example @trait list info { member: String } @info(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) structure A {} Copy would lead to the following code being rendered in the companion object of A : val hints : Hints = Hints( example.Info(List(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)), ) Copy This allows to query Hints for Info using the following syntax: hints.get(example.Info) Regarding the underlyingSchema value in the companion object of IntList, you can see that it is constructed using a list function. Conceptually, it encodes this : &quot;if I'm able to encode or decode an A in a specific format, then I should be able to encode or decode a List[A]&quot;. "},{"title":"Enumerations​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#enumerations","content":"TODO (waiting for smithy 2.0 which changes the syntax) "},{"title":"Services and endpoints","type":0,"sectionRef":"#","url":"docs/design/services","content":"","keywords":""},{"title":"The duality of final and initial algebras​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-duality-of-final-and-initial-algebras","content":"Before we dive into the core of the solution, one notion that is drastically helpful is the duality between finally-encoded algebras and initially-encoded algebras. Finally-encoded algebras are object-oriented encodings of a set of operations, just like above : operations are represented as methods in an interface. Interpretation of expressions written in terms of these methods does not involve any runtime transformation from one context to another : the method call is merely executed. In other words, when they are executed, expressions coming from finally-encoded algebras are already in their &quot;final form&quot;. Conversely, initially-encoded algebras represent expressions as data, implying that interpretation involves a transformation of this data into lower level method calls. However, data has the quality of being a first class construct in programming languages, meaning you can pass it around and use it as parameter to functions. This allows for the unification of code-paths, as the differences between some aspects of a bit of logic can be absorbed by the data and handled later on. Finally-encoded KVStore algebra : trait KVStore[Context[_]]{ def put(key: String, value: String) : Context[Unit] def get(key: String) : Context[Option[String]] def delete(key: String) : Context[Unit] } Copy Initially-encoded KVStore algebra : sealed trait KVStoreOp[Output] object KVStoreOp { case class Put(key: String, value: String) extends KVStore[Unit] case class Get(key: String) extends KVStore[Option[String]] case class Delete(key: String) extends KVStore[Unit] } Copy These two encodings contain a similar amount of information. It is nearly-trivial to go from a KVstore[Context] instance to a KVStoreOp ~&gt; Context natural transformation, and vice versa: trait ~&gt;[F[_], G[_]]{ def apply[A](fa: F[A]) : G[A] } def asNaturalTransformation[Context[_]](impl: KVStore[Context]) = new (KVStoreOp ~&gt; Context){ def apply[A](fa: KVStoreOp[A]) : Context[A] = fa match { case KVStoreOp.Put(key, value) =&gt; impl.put(key, value) case KVStoreOp.Get(key) =&gt; impl.get(key) case KVStoreOp.Delete(key) =&gt; impl.delete(key) } } def fromNaturalTransformation[Context[_]](run: KVStoreOp ~&gt; Context) = new KVStore[Context]{ def put(key: String, value: String) = run(KVStoreOp.Put(key, value)) def get(key: String) = run(KVStoreOp.Get(key)) def delete(key: String) = run(KVStoreOp.Delete(key)) } Copy This duality is heavily used by Smithy4s : finally-encoded interfaces are generally more natural to Scala developers, and are better supported in editors (autocompletion, etc). But from an implementation's perspective, the initial, data-based encoding is really interesting, because operations are reified as data-types that can be associated with instances of generic type-classes : it is possible to abstract over data, it is not possible to abstract over method calls. "},{"title":"A detour around kinds​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-detour-around-kinds","content":"The methods generated by Smithy4s are conceptually similar to the methods expressed in the example above, except that the output types are significantly more verbose. trait Interface[Context[_, _, _, _, _,]]{ def operation1(a: A, b: B) : Context[Input, Error, Output, StreamedInput, StreamedOutput] } Copy Let's address this awkwardness right away, by explaining the rationale behind this seemingly humongous signature : Input​ It's the input type of an operation. Typically, a case class that holds fields matching the method parameters. We keep track of it in the return type for several reasons: In the internal logic of Smithy4s, It prevents having to prematurely shoe-horn kinds into other kinds by means of injection/projection, which helps both implementor and compiler alikeIt will come in handy for the implementation of some pagination-aware interpreters, as pagination typically works by performing a modification of the previous input in order to get the next batch (page) of results. This implies that the input (and therefore its type) must be tracked across several requests resulting from a single method call. Error​ The execution of an operation can result in errors. The Smithy language allows for tying a list of errors to operations. When generating the associated code, Smithy4s synthesize a union. This allows the coproduct of errors associated to an operation to be represented as a bona fide Scala type, which we can abstract over via some type-class instance. This is also very useful for the writing of bi-functor interpreters, for users that are interested in this kind of UX. Output​ No surprise there : this is the data resulting from the run of the operation. StreamedInput, StreamedOutput​ Smithy supports the concept of Streaming. It is communicated as a trait that annotates a single field of the input shape or/and output shape of an operation. Scala does not have a &quot;standard&quot; way of expressing streaming semantics. Moreover, streaming constructs in Scala are heavily context dependant. It is therefore impossible for us to incorporate the concept of &quot;streaming&quot; to our Schema construct as it is meant to be context-free and third-party-free. To get some intuition for why that is : say we want to express streaming using fs2. If we naively generate a case class that has one of its fields annotated with @streaming, it means that the the field is of type fs2.Stream[F, A], which means that we either need to make a decision on what the F is, which is not okay for obvious reasons, or we need to propagate the F[_] type parameter upward to the case class. Now our Schema value, which accompanies the case-class, also have to carry the F ... this propagates throughout the whole codebase. We deemed that not acceptable. Rather than polluting all layers of abstraction, we decided to just have the concept of operation be impacted and hold the streamed type in a separate type parameter. This allows for interpreters from various ecosystem to emerge. It also has the quality of allowing users to access the unary component of outputs (ie, data that is communicated in the headers of HTTP responses) without necessarily allocating resources to consume the streamed component of the output. NB: at the time of writing this, Smithy4s does not have any streaming-aware interpreter implemented. But streaming is such a fundamental notion in remote interactions, and we had to devise a plan to ensure that third parties could decide to implement interpreters without waiting. "},{"title":"Transformation​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#transformation","content":"Because of the complex kinds we're dealing with, we codify a natural-transformation, called Smithy4s.Transformation that allows us to work at this level : trait Transformation[F[_, _, _, _, _], G[_, _, _, _, _]] { def apply[I, E, O, SI, SO](fa: F[I, E, O, SI, SO]): G[I, E, O, SI, SO] } Copy This is a mouthful, but conceptually, it's exactly the same as our good old polymorphic function typically aliased to ~&gt;. "},{"title":"Codifying the duality between initial and final algebras​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#codifying-the-duality-between-initial-and-final-algebras","content":"What we want users to manipulate is the final-encoded version of a service: a good-old object-oriented interface that has decent editor support. But we need the initial-encoded version to implement interpreters in a generic fashion. So we codify the duality to allow for switching from one to the other via an abstraction called Smithy4s.Service, which is the entry point to all interpreters. trait Service[Final[_[_, _, _, _, _]], Initial[_, _, _, _, _]] { def asTransformation[F[_, _, _, _, _,]](alg: Final[F]) : Transformation[Initial, F] def transform[F[_, _, _, _, _]](transformation: Transformation[Initial, F]) : Final[F] // ... } Copy Implementations of such interfaces are code-generated. This implies that any smithy Service shape gets translated as a finally-encoded interface, but also as an initially-encoded GADT "},{"title":"The high-level philosophy of Smithy4s​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-high-level-philosophy-of-smithy4s","content":"The goal of Smithy4s is to allow users to derive client stubs and routers in various protocols, by running the generated code (or instances of generated interfaces) in some one-liner functions. To that end, Smithy4s surfaces a number of abstractions (such as smithy4s.schema.Schema) that allow for the implementation of (very) polymorphic interpreters. These interpreters operate on the generated code, which reflects what the user defines in their smithy Specs. The abstractions used by interpreters contain all the elements that allow for turning a high-level method call (from an interface generated by Smithy4s) into a low level request of some sort, and then transform a low level response into the output of the method call. "},{"title":"Logical flow: client-side​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#logical-flow-client-side","content":"Conceptually, to derive a high-level client that uses some sort of Request =&gt; Response protocol, the implementation has to follow a sequence of steps: Assuming this method call : kvstore.get(&quot;key&quot;)turning the method call into a piece of data : KVStoreOp.Get(&quot;key&quot;) using the initially-encoded dual of the KVStore interfaceRetrieving the Smithy4s Schemas (input and output) associated to the Get operationCompiling the schema associated to the input of the Get operation into some encoding function : GetInput =&gt; RequestRunning the request through a low-level Request =&gt; Response function (like an HTTP client)Running Get into some function that gives us its GetInput representationCompiling the schema associated to the output (GetOutput ~= Option[String]) of the Get operation into some decoding function Response =&gt; Output So we get kvstore.get =&gt; KVStoreOp.Get =&gt; GetInput =&gt; Request =&gt; Response =&gt; GetOutput, which gives us the full data flow, client side. "},{"title":"Logical flow: server-side​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#logical-flow-server-side","content":"The server side is different in that we want to derive the Request =&gt; Response function from an instance of our interface (KVStore). The goal is to mechanically translate a request into a method call, and a method's output into a response. The sequence: From a given Request, find the corresponding operation Op (for instance, by means of HTTP path). Let's assume it's the get operation,Retrieve the Smithy4s Schemas (input and output) associated to the operation (KVStoreOp.Get)Compile a Request =&gt; GetInput decoding function, and run the Request through itFrom GetInput, recreate the KVStoreOp.Get instanceFrom KVStoreOp.Get, use the final-encoded dual of KVStoreOp to call the KVStore#get method (implemented by the user). This gets us an GetOutputCompile a GetOutput =&gt; Response encoding function from the schemas, and run the output through it So we get Request =&gt; KVStoreOp.GetInput =&gt; KVStoreOp.Get =&gt; kvstore.get =&gt; GetOutput =&gt; Response, which gives us the full data flow, service side. Both the service-side and client-side logical flows guide the design of the abstractions that are exposed by Smithy4s. "},{"title":"A note about efficiency​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-note-about-efficiency","content":"The flows described above are merely conceptual, and do not account for the optimisations involved to ensure that schemas are not recompiled into codecs on a per-request basis (which would greatly impact performance). Interpreters provided by Smithy4s (HTTP and co) are written to ensure that all compilation is performed ahead of receiving requests, by means of preliminary computations and caching. "},{"title":"The Endpoint abstraction​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-endpoint-abstraction","content":"The smithy4s.Endpoint abstraction ties a specific operation to the various schemas that are tied to it. trait Endpoint[Initial[_, _, _, _, _], I, E, O, SI, SO] { def shapeId : ShapeId def hints: Hints def input: Schema[I] def output: Schema[O] def streamedInput: StreamingSchema[SI] def streamedOutput: StreamingSchema[SO] def wrap(input: I): Initial[I, E, O, SI, SO] def errorable: Option[Errorable[E]] } Copy Endpoints are not type-classes. Instead, the Endpoint trait is extended by the companion object of each member of the GADT forming the initial-encoding of the service interface. So, going back to our KVStore, the corresponding sealed-trait would look like this : sealed trait KVStoreOp[Input, Error, Output, StreamedInput, StreamedOutput] Copy and the put operation would look like : case class Put(input: PutRequest) extends KVStoreOp[PutRequest, PutError, PutResult, Nothing, Nothing] object Put extends Endpoint[KVStoreOp, PutRequest, PutError, PutResult, Nothing, Nothing] with Errorable[PutError]{ val input = PutRequest.input val output = PutRequest.input val streamedInput = SteamingSchema.nothing val streamedOutput = StreamingSchema.nothing val errorable: Option[Errorable[PutResult]] = this // ... } Copy "},{"title":"A note on errors​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-note-on-errors","content":"As stated previously, Smithy4s generates a coproduct type for each operation, where the members of the coproduct point to the various errors listed in the smithy operation shape. Additionally, each structure annotated with @error in smithy is rendered as a case-class that extends Throwable, because Throwables are the de-facto standard of doing error handling on the JVM. Even libraries that use Either to perform error handling often represent the left-hand-side of the Either as some throwable type, to facilitate the absorption of errors into the error-channels of monadic constructs (IO.raiseError, etc) As a result, it is important for Smithy4s to expose functions that generically enable the filtering of throwables against the Error type parameter of an operation, so that interpreters can intercept errors and apply the correct encoding (dictated via Schema) before communicating them back to the caller over the wire. Conversely, it is important to expose a function that allows to go from the generic Error type parameter to Throwable, so that errors received via low-level communication channels can be turned into Throwable at the client call site, in order to populate the relevant error channel when exposing mono-functor semantics. Therefore, when a smithy operation has errors defined, the corresponding smithy4s.Endpoint also extends the Errorable interface, which looks like this : trait Errorable[E] { def error: UnionSchema[E] def liftError(throwable: Throwable): Option[E] def unliftError(e: E): Throwable } Copy "},{"title":"Services and endpoints​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#services-and-endpoints","content":"In order to implement any server-side interpreters, it is required to have a list of endpoints. That list is used to implement some matching logic based on the shapeId and/or the hints associated to the endpoints, in order to deterministically decide where to route a low level Request to a specific Endpoint instance. For instance, smithy provides a @http trait out of the box that can annotate operations : service KVStore { operations: [Get, Put] } @http(method: &quot;GET&quot;, uri: &quot;/resource/${key}, code: 200) operation Get { input: GetInput output: GetOutput } structure GetInput { @httpLabel key: String } structure GetOutput { value: String } @http(method: &quot;PUT&quot;, uri: &quot;/resource/${key}, code: 200) operation Put { } structure PutInput { @httpLabel key: String, @httpPayload value: String } Copy Each @http occurrence get translated to a scala value in the Hints associated to the corresponding endpoint. On server-side, having a list of all the endpoints associated to a service allows for creating a routing logic that dispatches an HTTP Request to the correct endpoint.On client-side, a method call to a service stub gets translated to an instance of the corresponding GADT member. From there, we have to retrieve the schemas associated to the member in question. Additionally, we need to extract the input value out of the member, to run it through an encoder derived from the the associated Schema. Therefore, the Service abstraction needs to be enriched with the following methods : trait Service[Final[_[_, _, _, _, _]], Initial[_, _, _, _, _]] { // ... // useful for server-side def endpoints: List[Endpoint[Initial, _, _, _, _, _]] // useful for client-side def endpoint[I, E, O, SI, SO](op: Initial[I, E, O, SI, SO]): (I, Endpoint[Initial, I, E, O, SI, SO]) } Copy "},{"title":"Conclusion and complete interfaces​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#conclusion-and-complete-interfaces","content":"Here are links to the complete interfaces discussed in this chapter. ServiceEndpoint "},{"title":"Extracting Request Information","type":0,"sectionRef":"#","url":"docs/guides/extract-request-info","content":"","keywords":""},{"title":"What is IOLocal?​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#what-is-iolocal","content":"IOLocalis a construct that allows for sharing context across the scope of a Fiber. This means it allows you to get and set some value A in the IOLocal. This value will be accessible across the current Fiber. As a Fiber is forked into new fibers, the value of A is carried over to the new Fiber. However, the new Fiber will not be able to update the value kept on its parent or sibling fibers. This diagram, adapted from the IOLocal docs, illustrates this well:  "},{"title":"Example Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#example-implementation","content":""},{"title":"Smithy Spec​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#smithy-spec","content":"For this example, we are going to be working with the following smithy specification (taken from smithy4s repo): namespace smithy4s.hello use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, // Indicates that all operations in `HelloWorldService`, // here limited to Hello, can return `GenericServerError`. errors: [GenericServerError], operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String } structure Greeting { @required message: String } Copy See our getting started documentation for instructions on how to use this specification to generate scala code. "},{"title":"Service Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#service-implementation","content":"Let's start by creating a case class that we will use to hold the value of some headers from our request. case class RequestInfo(contentType: String, userAgent: String) Copy This class will give us a spot to place the Content-Type and User-Agent headers, respectively. These are just shown as an example. We could instead pass any other header or part of the request. From here, we can implement the HelloWorldService interface that smithy4s generated from the specification above. import smithy4s.hello._ import cats.effect.IO import cats.effect.IOLocal final class HelloWorldServiceImpl(requestInfo: IO[RequestInfo]) extends HelloWorldService[IO] { def hello(name: String, town: Option[String]): IO[Greeting] = requestInfo.flatMap { reqInfo: RequestInfo =&gt; IO.println(&quot;REQUEST_INFO: &quot; + reqInfo) .as(Greeting(s&quot;Hello, $name&quot;)) } } Copy This is a basic implementation that, in addition to returning a Greeting, prints the RequestInfo out to the console. Note that it is getting the RequestInfo from the IO[RequestInfo] that is being passed in as a constructor parameter. This IOwill be created using the sameIOLocalinstance is passed to our middleware implementation. That way, the middleware can set theRequestInfo` value that we are reading here. "},{"title":"Middleware​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#middleware","content":"Below is the middleware implementation. It extracts the Content-Type and User-Agent headers and passes them along in the IOLocalinstance it is provided. import cats.data._ import org.http4s.HttpRoutes import cats.syntax.all._ import org.http4s.headers.{`Content-Type`, `User-Agent`} object Middleware { def withRequestInfo( routes: HttpRoutes[IO], local: IOLocal[Option[RequestInfo]] ): HttpRoutes[IO] = HttpRoutes[IO] { request =&gt; val requestInfo = for { contentType &lt;- request.headers.get[`Content-Type`].map(ct =&gt; s&quot;${ct.mediaType.mainType}/${ct.mediaType.subType}&quot;) userAgent &lt;- request.headers.get[`User-Agent`].map(_.product.toString) } yield RequestInfo( contentType, userAgent ) OptionT.liftF(local.set(requestInfo)) *&gt; routes(request) } } Copy "},{"title":"Wiring it Together​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#wiring-it-together","content":"Now that we have our service implementation and our middleware, we need to combine them to create our application. import cats.effect.kernel.Resource object Routes { private val docs = smithy4s.http4s.swagger.docs[IO](smithy4s.hello.HelloWorldService) def getAll(local: IOLocal[Option[RequestInfo]]): Resource[IO, HttpRoutes[IO]] = { val getRequestInfo: IO[RequestInfo] = local.get.flatMap { case Some(value) =&gt; IO.pure(value) case None =&gt; IO.raiseError(new IllegalAccessException(&quot;Tried to access the value outside of the lifecycle of an http request&quot;)) } smithy4s.http4s.SimpleRestJsonBuilder .routes(new HelloWorldServiceImpl(getRequestInfo)) .resource .map { routes =&gt; Middleware.withRequestInfo(routes &lt;+&gt; docs, local) } } } Copy Here we are creating our routes (with swagger docs) and passing them to our middleware. The result of applying the Middleware is our final routes. We also turn our IOLocal into an IO[RequestInfo] for the HelloWorldServiceImpl. We do this because the service implementation does not need to know that the value is coming from an IOLocal or that the value is optional (since it will always be populated by our middleware). Doing it this way allows us to reduce the complexity in the service implementation. Finally, we create our main class and construct the http4s server. import cats.effect.IOApp import com.comcast.ip4s._ import org.http4s.ember.server.EmberServerBuilder object Main extends IOApp.Simple { def run: IO[Unit] = IOLocal(Option.empty[RequestInfo]).flatMap { local =&gt; Routes .getAll(local) .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withHost(host&quot;localhost&quot;) .withPort(port&quot;9000&quot;) .withHttpApp(routes.orNotFound) .build } .useForever } } Copy Notice that we create the IOLocal with Option.empty[RequestInfo]. This is because IOLocal requires a value to be constructed. However, this value will never be used in practice. This is because we are setting the value in the middleware on every request prior to the request being handled by our HelloWorldService implementation. "},{"title":"Testing it out​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#testing-it-out","content":"With the above in place, we can run our application and test it out. curl -X 'POST' \\ 'http://localhost:9000/Test' \\ -H 'User-Agent: Chrome/103.0.0.0' \\ -H 'Content-Type: application/json' Copy Running this curl will cause the following to print out to the console: REQUEST_INFO: RequestInfo(Some(application/json),Some(Chrome/103.0.0.0)) Copy "},{"title":"Alternative Methods​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#alternative-methods","content":"If you are working with a tagless F[_] rather than IO directly, you may want to check out Chris Davenport's implementation of FiberLocal. You can also use Kleisli to accomplish the same things we showed in this tutorial and you are welcome to do so if you prefer that. We opted to show an example with IOLocal since it allows users to use IO directly, without monad transformers, which many users will be more comfortable with. Similarly, you could use Local from cats-mtl or probably a variety of other approaches. We recommend you use whatever fits the best with your current application design. "},{"title":"Editor Support","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/editor-support","content":"Editor Support Disney Streaming develops and maintains a Smithy language server, that implements features such as jump-to-definition, auto-completion, validation diagnostics. We also provide a VS Code extension that talks to the language server, and provides a smooth developer experience.","keywords":""},{"title":"Smithy traits","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/traits","content":"","keywords":""},{"title":"Creating your own traits​","type":1,"pageTitle":"Smithy traits","url":"docs/the-smithy-idl/traits#creating-your-own-traits","content":"Smithy makes it really easy to create your own traits: namespace foo @trait(selector: is(structure)) string customThing @customThing(&quot;hello&quot;) structure MyStructure { } Copy "},{"title":"Regarding Smithy4s handling of traits​","type":1,"pageTitle":"Smithy traits","url":"docs/the-smithy-idl/traits#regarding-smithy4s-handling-of-traits","content":"Smithy4s automatically creates corresponding values in the generated Scala code, for all the annotations it finds, whether defined in the smithy prelude, or defined by users. These values can be retrieved via some interfaces that will be documented in a near future. "},{"title":"The Smithy IDL","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/smithy-idl","content":"","keywords":""},{"title":"The smithy metamodel​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#the-smithy-metamodel","content":"In this section, we'll list various available shapes that let you define data and operations in smithy, and how they translate in the Scala code generated by Smithy4s. "},{"title":"Primitive types​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#primitive-types","content":"Smithy provides the following &quot;primitive&quot; types out of the box. BooleanStringIntegerLongFloatShortDoubleByteBigIntegerBigDecimalBlob (smithy4s.ByteArray, wrapper to Array[Byte])Timestamp (smithy4s.Timestamp, translated from/to java or javascript time types)Document (smithy4s.Document, a bespoke Json ADT) "},{"title":"Named primitives​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#named-primitives","content":"Smithy lets you define custom names for primitive types: namespace foo integer Age long Identifier Copy These get translated as unboxed type wrappers, or newtypes, that look like a case class but do not induce any boxing at runtime. "},{"title":"Collection types​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#collection-types","content":"Smithy provides 3 different shapes of collections: lists, sets, and maps. They translate to the corresponding scala.collection types in the generated Scala code. namespace foo list IntList { member: Integer } set StringSet { member: Set } // At this time, only string shapes can be used as keys to map. map AgeMap { key: String, value: Integer } Copy "},{"title":"Structures​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#structures","content":"Structures are product types. In Scala, they naturally translate to case classes. namespace foo structure Person { @required firstName: String, @required lastName: String, dateOfBirth: Timestamp } Copy "},{"title":"Unions​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#unions","content":"Unions are coproduct types. In Scala, they quite naturally translate to sealed traits. Union members can target any data shape, be it a structure or a primitive type. namespace foo structure Cat { name: String } structure Dog { name: String } union Animal { cat: Cat, dog: Dog } Copy "},{"title":"Operations and services​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#operations-and-services","content":"Operations​ Operations are essentially an optional Input, an optional Output, and an optional list of errors. Inputs, outputs and errors all have to be structure shapes. namespace foo operation Greet { input: GreetInput, output: GreetOutput, errors: [BadInput] } structure GreetInput { name: String } structure GreetOutput { message: String } @error(&quot;client&quot;) structure BadInput { message: String } Copy Errors​ Regarding errors, smithy4s translates them as case classes extending Throwable. The getMessage method of the throwable is implemented in terms of the following (based on the first match): a field annotated with the @errorMessage traita field named message Services​ Services are basically a list of operations, and an optional list of errors. namespace foo service HelloService { operations: [Greet], errors: [ServerError] } @error(&quot;server&quot;) structure ServerError { message: String } Copy Smithy4s translates them in the following fashion: package object foo { type HelloService[F[_]] = HelloServiceGen[???] } Copy HelloService is type alias that exposes a normal &quot;functor-shaped&quot; type parameter: we are aware that the most common usecase of Smithy4s abides by the &quot;capatibility trait&quot; pattern (or tagless-final), against effect types that probably abide by the cats-effect semantics. However, the actual interface is HelloServiceGen, which has a higher degree of polymorphism. It looks like this: package foo trait HelloServiceGen[P[_, _, _, _, _]]{ def greet(name: String) : P[GreetInput, Greet.Error, GreetOutput, Nothing, Nothing] } Copy P represents an abstract context against which operations are going to run. The abstract context has 5 type parameters: input,error,output,streamed input (Nothing, most of the time)streamed output (Nothing, most of the time) Keeping track of these parameters is really important for the implementation intepreters. It also opens the door for providing interpreters that work against bi-functors (EitherT[IO, *, *]) without changing the generated code. "},{"title":"Currently not supported (in particular)​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#currently-not-supported-in-particular","content":"Smithy has a resource type of shape, that represents CRUD specialised services. It is currently not supported in Smithy4s. "}]