[{"title":"Unions and sealed traits","type":0,"sectionRef":"#","url":"docs/codegen/unions","content":"","keywords":""},{"title":"Flattening of structure members​","type":1,"pageTitle":"Unions and sealed traits","url":"docs/codegen/unions#flattening-of-structure-members","content":"Under certain conditions, Smithy4s offers a mechanism to &quot;flatten&quot; structure members directly as a member of the sealed trait. Head over to the page explaining code-gen customisation for a detailed explanation. "},{"title":"Regarding JSON encoding​","type":1,"pageTitle":"Unions and sealed traits","url":"docs/codegen/unions#regarding-json-encoding","content":"Smithy4s does not rely on the classic automated derivation mechanisms to determine how unions should be encoded in JSON. Rather, the Smithy models dictates the encoding. Indeed, there are multiple ways to encode unions in JSON. By default, the specification of the Smithy language hints that the tagged-union encoding should be used. This is arguably the best encoding for unions, as it works with members of any type (not just structures), and does not require backtracking during parsing, which makes it more efficient. However, Smithy4s provides support for two additional encodings: discriminated and untagged, which users can opt-in via the smithy4s.api#discriminated and smithy4s.api#untagged trait, respectively. These are mostly offered as a way to retrofit existing APIs in Smithy. Tagged union​ This is the default behaviour, and happens to visually match how Smithy unions are declared. In this encoding, the union is encoded as a JSON object with a single key-value pair, the key signalling which alternative has been encoded. union Tagged { first: String second: IntWrapper } structure IntWrapper { int: Integer }  The following instances of Tagged Tagged.FirstCase(&quot;smithy4s&quot;) Tagged.SecondCase(IntWrapper(42)))  are encoded as such : { &quot;first&quot;: &quot;smithy4s&quot; } { &quot;second&quot;: { &quot;int&quot;: 42 } }  Untagged union​ Untagged unions are supported via an annotation: @untagged. Despite the smaller payload size this encoding produces, it is arguably the worst way of encoding unions, as it may require backtracking multiple times on the parsing side. Use this carefully, preferably only when you need to retrofit an existing API into Smithy use smithy4s.api#untagged @untagged union Untagged { first: String second: IntWrapper } structure IntWrapper { int: Integer }  The following instances of Untagged Untagged.FirstCase(&quot;smithy4s&quot;) Untagged.SecondCase(Two(42)))  are encoded as such : &quot;smithy4s&quot; { &quot;int&quot;: 42 }  Discriminated union​ Discriminated union are supported via an annotation: @discriminated(&quot;tpe&quot;), and work only when all members of the union are structures. In this encoding, the discriminator is inlined as a JSON field within JSON object resulting from the encoding of the member. Despite the JSON payload exhibiting less nesting than in the tagged union encoding, this encoding often leads to bigger payloads, and requires backtracking once during parsing. use smithy4s.api#discriminated @discriminated(&quot;tpe&quot;) union Discriminated { first: StringWrapper second: IntWrapper } structure StringWrapper { string: String } structure IntWrapper { int: Integer }  The following instances of Discriminated Discriminated.FirstCase(StringWrapper(&quot;smithy4s&quot;)) Discriminated.SecondCase(IntWrapper(42)))  are encoded as such { &quot;tpe&quot;: &quot;first&quot;, &quot;string&quot;: &quot;smithy4s&quot; } { &quot;tpe&quot;: &quot;second&quot;, &quot;int&quot;: 42 }  "},{"title":"Customisation","type":0,"sectionRef":"#","url":"docs/codegen/customisation","content":"","keywords":""},{"title":"Packed inputs​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#packed-inputs","content":"By default, Smithy4s generates methods the parameters of which map to the fields of the input structure of the corresponding operation. For instance : service PackedInputsService { version: &quot;1.0.0&quot; operations: [PackedInputOperation] } operation PackedInputOperation { input: PackedInput } structure PackedInput { @required a: String @required b: String }  leads to something conceptually equivalent to : trait PackedInputServiceGen[F[_]] { def packedInputOperation(a: String, b: String) : F[Unit] }  It is however possible to annotate the service (or operation) definition with the smithy4s.meta#packedInputs trait, in order for the rendered method to contain a single parameter, typed with actual input case class of the operation. For instance : use smithy4s.meta#packedInputs @packedInputs service PackedInputsService { version: &quot;1.0.0&quot; operations: [PackedInputOperation] }  will produce the following Scala code trait PackedInputServiceGen[F[_]] { def packedInputOperation(input: PackedInput) : F[Unit] }  "},{"title":"ADT Member Trait​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#adt-member-trait","content":"The default behavior of Smithy4s when rendering unions that target structures is to render the structure in a separate file from the union that targets it. This makes sense if the structure is used in other contexts other than the union. However, it also causes an extra level of nesting within the union. This is because the union will create another case class to contain your structure case class. For example: union OrderType { inStore: InStoreOrder } structure InStoreOrder { @required id: OrderNumber locationId: String }  Would render the following scala code: OrderType.scala: sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreCase(inStore: InStoreOrder) extends OrderType  InStoreOrder.scala: case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None)  The sealed hierarchy OrderType has a member named InStoreCase. This is becauseInStoreOrder is rendered in a separate file and OrderType is sealed. However, adding the adtMember trait to the InStoreOrder structure changes this. union OrderType { inStore: InStoreOrder } @adtMember(OrderType) // added the adtMember trait here structure InStoreOrder { @required id: OrderNumber locationId: String }  sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None) extends OrderType  The IsStoreOrder class has now been updated to be rendered directly as a member of the OrderTypesealed hierarchy. The adtMember trait can be applied to any structure as long as said structure is targeted by EXACTLY ONE union.This means it must be targeted by the union that is provided as parameter to the adtMember trait. This constraint is fulfilled above because OrderType targets InStoreOrder and InStoreOrder is annotated with @adtMember(OrderType). The structure annotated with adtMember (e.g. InStoreOrder) also must not be targeted by any other structures or unions in the model. There is a validator that will make sure these requirements are met whenever the adtMember trait is in use. Note: The adtMember trait has NO impact on the serialization/deserialization behaviors of Smithy4s. The only thing it changes is what the generated code looks like. This is accomplished by keeping the rendered schemas equivalent, even if the case class is rendered in a different place. "},{"title":"Specialized collection types​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#specialized-collection-types","content":"Smithy supports list and set, Smithy4s renders that to List[A] and Set[A] respectively. You can also use the @uniqueItems annotation on list which is equivalent to set. Smithy4s has support for two specialized collection types: Vector and IndexedSeq. The following examples show how to use them: use smithy4s.meta#indexedSeq use smithy4s.meta#vector @indexedSeq list SomeIndexSeq { member: String } @vector list SomeVector { member: String }  Both annotations are only applicable on list shapes. You can't mix @vector with @indexedSeq, and neither one can be used with @uniqueItems. "},{"title":"Refinements​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#refinements","content":"Refinements provide a mechanism for using types that you control inside the code generated by smithy4s. Creating a refinement for use in your application starts with creating a custom smithy trait that represents the refinement. namespace test @trait(selector: &quot;string&quot;) structure emailFormat {}  This trait can now be used on string shapes to indicate that they must match an email format. @emailFormat string Email  Now we need to tell smithy4s that we want to represent shapes annotated with @emailFormat as a custom type that we define. Given a custom email type such as: // Note, we recommend using a newtype library over a regular case class in most cases // But this is shown to simplify the example case class Email(value: String) object Email { private def isValidEmail(value: String): Boolean = ??? def apply(value: String): Either[String, Email] = if (isValidEmail(value)) Right(new Email(value)) else Left(&quot;Email is not valid&quot;) }  Next, we will need to provide a way for smithy4s to understand how to construct and deconstruct our Email type. We do this by defining an instance of a RefinementProvider. Note that the RefinementProvider we create MUST be implicit. // package myapp.types import smithy4s._ case class Email(value: String) object Email { private def isValidEmail(value: String): Boolean = ??? def apply(value: String): Either[String, Email] = if (isValidEmail(value)) Right(new Email(value)) else Left(&quot;Email is not valid&quot;) implicit val provider = Refinement.drivenBy[EmailFormat]( Email.apply, // Tells smithy4s how to create an Email (or get an error message) given a string (e: Email) =&gt; e.value // Tells smithy4s how to get a string from an Email ) }  info The EmailFormat type passed as a type parameter to Refinement.drivenBy is the type that smithy4s generated from our @emailFormat trait we defined in our smithy file earlier. Now, we just have one thing left to do: tell smithy4s where to find our custom Email type. We do this using a trait called smithy4s.meta#refinement. use smithy4s.meta#refinement apply test#emailFormat @refinement( targetType: &quot;myapp.types.Email&quot; )  Here we are applying the refinement trait to our emailFormat trait we defined earlier. We are providing the targetType which is our Email case class we defined. Smithy4s will now be able to update how it does code generation to reference our custom Email type. info If the provider was not in the companion object of our targetType, we would need to provide the providerImport to the refinement trait so that smithy4s would be able to find it. For example: use smithy4s.meta#refinement apply test#emailFormat @refinement( targetType: &quot;myapp.types.Email&quot;, providerImport: &quot;myapp.types.providers._&quot; ) Whether the provider is in the companion object or not, it must be implicit. "},{"title":"Unwrapping​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#unwrapping","content":"By default, smithy4s will wrap all standalone primitive types in a Newtype. A standalone primitive type is one that is defined like the following: string Email // standalone primitive structure Test { email: Email other: String // not a standalone primitive }  Given this example, smithy4s would generate something like the following: final case class Test(email: Email, other: String)  This wrapping may be undesirable in some circumstances. As such, we've provided the smithy4s.meta#unwrap trait. This trait tells the smithy4s code generation to not wrap these types in a newtype when they are used. use smithy4s.meta#unwrap @unwrap string Email structure Test { email: Email other: String }  This would now generate something like: final case class Test(email: String, other: String)  This can be particularly useful when working with refinement types (see above for details on refinements). By default, any type that is refined will be generated inside of a newtype. If you don't want this, you can mark the type with the unwrap trait. @trait(selector: &quot;string&quot;) structure emailFormat {} @emailFormat @unwrap string Email  info By default, smithy4s renders collection types as unwrapped EXCEPT when the collection has been refined. In this case, the collection will be rendered within a newtype by default. If you wish your refined collection be rendered unwrapped, you can accomplish this using the same @unwrap trait annotation on it. "},{"title":"Default rendering​","type":1,"pageTitle":"Customisation","url":"docs/codegen/customisation#default-rendering","content":"Smithy4s allows you to customize how defaults on the fields of smithy structures are rendered inside of case classes. There are three options: FULLOPTION_ONLYNONE The default is FULL. This value is set using metadata which means that the setting will be applied to all the rendering done by smithy4s. FULL​ FULL means that default values are rendered for all field types. For example: metadata smithy4sDefaultRenderMode = &quot;FULL&quot; structure FullExample { one: Integer = 1 two: String @required three: String }  would render to something like: case class FullExample(three: String, one: Int = 1, two: Option[String] = None)  Notice how the fields above are ordered. The reason for this is that fields are ordered as: Required FieldsFields with defaultsOptional Fields OPTION_ONLY​ metadata smithy4sDefaultRenderMode = &quot;OPTION_ONLY&quot; structure OptionExample { one: Integer = 1 two: String @required three: String }  would render to something like: case class FullExample(one: String, three: String, two: Option[String] = None)  Now one doesn't have a default rendered and as such it is placed first in the case class. NONE​ metadata smithy4sDefaultRenderMode = &quot;NONE&quot; structure OptionExample { one: Integer = 1 two: String @required three: String }  would render to something like: case class FullExample(one: String, two: Option[String], three: String)  Now none of the fields are rendered with defaults. As such, the order of the fields is the same as is defined in the smithy structure. caution The presence of the smithy4sDefaultRenderMode metadata does NOT change the way smithy4s codecs behave. As such, defaults will still be used when decoding fields inside of clients and servers. This feature is purely for changing the generated code for your convenience. "},{"title":"General design principles","type":0,"sectionRef":"#","url":"docs/design/design","content":"General design principles Before we dive in to the design elements, it is important to state that Smithy4s is designed with the following constraints : optimised for number of usecases: Smithy4s is not (just) an http/json library, it can/could be used for a great many things, such as AWS SDKs, CLIs, UIs, etc. Therefore, following the protocol-agnostic nature of smithy, the code generated by Smithy4s is not biased towards any protocol or serialisation mechanism, nor any runtime or Scala version.optimised for correctness over compatibility: there is strictly no guarantee made regarding backward compatibility of the generated code when users evolve their smithy schemas. Therefore, users are expected to regenerate the code at use-site, instead of relying on artifacts that would contain the generated code... However, users do get idiomatic Scala code, including case classes / sealed traits (which are notoriously hard to evolve in binary compatible ways), and this generated code correctly reflects the smithy specifications.decoupled from third-party libraries: the generated code depends only on smithy4s-core for compilation, which does not pull third-party dependencies (not even a general purpose libraries that the maintainers love, like cats) These constraints may sound counter-intuitive, obtuse, even alien. The internals of this library are not beginner friendly. They rely on advanced features of the Scala compiler that may unfortunately scare away newcomers interested in contributing. If you're not discouraged yet, do not hesitate to ask questions using github discussions, we will do our best to answer them!","keywords":""},{"title":"Datatypes and schemas","type":0,"sectionRef":"#","url":"docs/design/schemas","content":"","keywords":""},{"title":"The Schema GADT​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#the-schema-gadt","content":"Each datatype generated by Smithy4s is accompanied by a schema value in its companion object, which contains an expression of type smithy4s.schema.Schema that captures everything needed to deconstruct/reconstruct instances of the datatype. smithy4s.schema.Schema is a Generalised Algebraic Datatype (or GADT for short) that can be used to precisely reference all the information needed to traverse datatypes that can be expressed in Smithy. It is a bit like JVM reflection, except that it exposes higher-level information about the datatypes. It achieves this by exposing building blocks that accurately reflect what is possible to express in the Smithy language. These building blocks form a metamodel: a model for models. And, unlike JVM reflection, using schemas is type-safe. The Schema type reflects the various ways of constructing datatypes in Smithy. It is encoded as a sealed trait, the members of which capture the following aspects of the Smithy language: PrimitivesListsSetsMapsEnumerationsStructuresUnions For a Scala type called Foo, formulating a Schema[Foo] is equivalent to exhaustively capturing the information needed for the serialisation and deserialisation of Foo in any format (JSON, XML, ...). Indeed, for any Codec[_] construct provided by third-party libraries, it is possible to write a generic def compile(schema: Schema[A]): Codec[A] function that produces the Codec for A based on the information held by the Schema. Why do things this way? Why not just render Codec during code generation? The reason is that we want for the generated code to be completely decoupled from any serialisation format or library, and for the user to have the ability to wire that generated code in different ways, without having to change anything in the build. Moreover, this approach has proven that it allows for a bounded investment for adding interop with various libraries, and offers really good testability. "},{"title":"Hints​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#hints","content":"In Smithy, all shapes (and members of composite shapes) can be annotated with traits. Smithy4s generically translates these annotations to instances of the corresponding generated classes, which means that Smithy4s supports generating user defined traits that it has zero knowledge of. So if you have the following Smithy description: namespace example @trait structure metadata { @required description: String } @metadata(description: &quot;This is my own integer shape&quot;) integer MyInt  When processing this Smithy model, Smithy4s renders a case class Metadata(description: String), with an assocaited ShapeTag[Metadata] instance, and the following expression in the companion object of MyInt: val hints = Hints( Metadata(&quot;this is my own integer shape&quot;) )  The smithy4s.Hints type is a polymorphic map that can hold shapes, keyed by ShapeTag. A ShapeTag is a uniquely identified tag that uses referential equality. Every schema can hold a Hints instance, which means that in addition to the datatype structures, Schemas also offer an accurate reflection of the trait values that annotate shapes in the smithy models. Smithy4s uses these hints to implement interpreters. For instance, the smithy.api#jsonName smithy trait translates to a smithy.api.JsonName Scala type, that we can query from a Hints instance when implementing a Schema ~&gt; JsonCodec transformation. This allows to give users a little customisability in the json serialisation of their datatypes. "},{"title":"Structures​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#structures","content":"A structure, also referred to as product, or record, is a construct that groups several values together. Typically, it translates naturally to a case class. namespace example structure Foo { @required a: Integer @length(min: 1) b: String }  ...and the associated, generated Scala code: package example import smithy4s.schema.Schema._ case class Foo(a: Int, b: Option[String] = None) object Foo extends smithy4s.ShapeTag.Companion[Foo] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;Foo&quot;) implicit val schema: smithy4s.Schema[Foo] = struct( int.required[Foo](&quot;a&quot;, _.a), string.optional[Foo](&quot;b&quot;, _.b).addHints(smithy.api.Length(Some(1), None)) ){ Foo.apply }.withId(id) }  As you can see, the Smithy structure translates quite naturally to a Scala case class. Every member of the structure that does not have the @required trait is rendered as an optional value defaulting to None (by default, smithy4s sorts the fields before rendering the case class so that the required ones appear before the optional ones. That is a pragmatic decision that tends to improve UX for users.) Indeed, for each field, there is an associated reference to a schema (int, string, ...), a string label, and a lambda calling the case class accessor that allows the retrieval of the associated field value. Additionally, the constructor of the case class is also referenced in the Schema. Typically, the accessors are needed for encoding the data, which involves destructuring it to access its individual components. The labels are there to cater to serialisation mechanisms like JSON or XML, where sub-components of a piece of data are labelled and nested under a larger block. Conversely, the constructor is used for deserialisation, which involves reconstructing the data after all of its component values have been successfully deserialised. Another detail is the presence of the addHints call on field labelled with b. This is due to the presence of the length trait (from the smithy.api namespace, aka the prelude) on the corresponding b member of the smithy Foo shape. Note related to optional and required​ You may have noticed the required and optional methods, which create Field instances from Schemas, in order to pass them to structures. In Smithy4s, the concept of Option only exists relatively to struct calls. It is not possible to construct a Schema[Option[A]] on its own. The rationale is that having a first class Option schema constructor leads to leaks in the implementation of serialisation mechanisms, as None typically represents the absence of value, and allowing for serialising an absence of value in formats that typically do not support it implies the leak of Option (or equivalent) in various interfaces. Additionally, a first class Option schema constructor would allow to create schemas for Option[Option[Option[Int]]], and even though we recognise that there are some things that could be encoded this way, it is just not a very pragmatic possibility, and opens the door for easy violation of round-trip properties that any serialisation technology should respect. For instance: Some(None) and None can easily have the same encoding in Json, so how do you distinguish between the two during decoding? "},{"title":"Unions​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#unions","content":"Union, also referred to as coproduct, or sum type, is a construct that expresses sealed polymorphism. It is the dual of a structure: when structures express that you have A AND B, unions express that you can have A OR B. The way this is expressed in Smithy looks like this: namespace example union Bar { a: Integer b: String }  This hints at the default serialisation that AWS has intended to use on unions expressed in smithy, namely tagged unions. Indeed, the AWS json-centric protocols specifies that shapes like these should be serialised in objects with a single key/value entry, where the key receives the value of the tag. For instance, { &quot;a&quot; : 1 } or { &quot;b&quot; : &quot;two&quot; }. There are some very relevant technical reasons for it, but this way of encoding unions/co-products in JSON is arguably the best. It may also be familiar to Circe users as it's the default encoding of co-products in circe-generic. Regarding the Scala code rendered by Smithy4s for the above Smithy specification, it looks like this: package example import smithy4s.schema.Schema._ sealed trait Bar extends scala.Product with scala.Serializable object Bar extends smithy4s.ShapeTag.Companion[Bar] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;Bar&quot;) case class ACase(a: Int) extends Bar case class BCase(b: String) extends Bar object ACase { val hints : smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[ACase] = bijection(int.addHints(hints), ACase(_), _.a) val alt = schema.oneOf[Bar](&quot;a&quot;) } object BCase { val hints : smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[BCase] = bijection(string.addHints(hints), BCase(_), _.b) val alt = schema.oneOf[Bar](&quot;b&quot;) } implicit val schema: smithy4s.Schema[Bar] = union( ACase.alt, BCase.alt, ){ case c : ACase =&gt; ACase.alt(c) case c : BCase =&gt; BCase.alt(c) }.withId(id) }  The union is rendered as an ADT (sealed trait), the members of which are single-value case classes wrapping values of the types referenced by the union member. The Case suffix is added as a way to reduce risk of collision between the generated code and other types (especially the types being wrapped). Each ADT member is accompanied by its own schema, which is not provided implicitly, in an effort to retain coherence in the type-class instances, and avoid the situation where you'd have different behaviours during serialisation based on whether you've up-casted a member to the ADT. Additionally, the companion objects of each ADT members contain an alt value (for &quot;alternative&quot;), which is the union's equivalent to the structure's field. Much like a field, an alt contains a label, and can carry hints. But unlike a field, which contains an accessor, the alt contains the function to &quot;inject&quot; (up-cast) the member into the union. This is useful for de-serialisation, when, after successfully de-serialising a member of a union, you need to inject it into the ADT to return the expected type. As for the union's schema, it is somewhat similar to the structure's, in that it references all its alternatives. But instead of a structure's constructor, we have a dispatch function instead, which contains a pattern match against all the possible members, and dispatches the &quot;down-casted&quot; value to its corresponding alternative. This is useful for serialisation, when the behaviour of the alternatives can only be applied to values of the corresponding type: &quot;if my ADT is an A, then I serialise the A, and add a discriminating tag to the serialised A&quot;. "},{"title":"Named simple shapes​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#named-simple-shapes","content":"Smithy allows for the creation of named shapes that reference &quot;primitive types&quot;: namespace example integer MyInt  Smithy4s translates this to a Scala newtype : a zero-overhead wrapper for the underling type (in this case, Int): package example object MyInt extends Newtype[Int] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;MyInt&quot;) val hints : smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema : smithy4s.Schema[Int] = int.withId(id).addHints(hints) implicit val schema : smithy4s.Schema[MyInt] = bijection(underlyingSchema, MyInt(_), (_ : MyInt).value) }  A MyInt type alias, pointing to the MyInt.Type type member, is rendered in the example package object, which makes it possible to write such code: val myInt: MyInt = MyInt(1) // val int: Int = myInt // doesn't compile because MyInt is not an Int at compile time. val int: Int = myInt.value  You may have noticed that the schema value is using bijection. Additionally to the GADT members stated previously, Schema also has a BijectionSchema member, which allows to apply bidirectional transformation on other Schemas. This is useful for the case of newtypes: if we are able to derive a codec that can encode and decode Int, it should be possible to derive a codec that encodes and decodes MyInt. "},{"title":"Collections​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#collections","content":"Smithy supports three types of collections out of the box : set (bound to disappear in smithy 2.0 in favour of the @uniqueItems trait)listmap Additionally, Smithy4s allows users to annotate list shapes to customise the type of collection used during code-generation. Smithy does not support generics, therefore all collection are named. Though seemingly tedious, it makes it easier to build tooling (and probably helps languages that do not support generics). Provided the following shape : namespace example list IntList { member: Integer }  You get the following Scala code : package example object IntList extends Newtype[List[Int]] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;IntList&quot;) val hints : smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema : smithy4s.Schema[List[Int]] = list(int).withId(id).addHints(hints) implicit val schema : smithy4s.Schema[IntList] = bijection(underlyingSchema, IntList(_), (_ : IntList).value) }  It is really similar to named primitives. However, for pragmatic reasons, when a structure references a collection in one of its members, the Scala field gets rendered using the de-aliased type (as opposed to the newtype). The IntList newtype is generated mostly as a way to hold the hints and schemas corresponding to the smithy IntList shape. Additionally, the IntList newtype is used by Smithy4s to render Hints values : namespace example @trait list info { member: String } @info(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) structure A {}  would lead to the following code being rendered in the companion object of A : val hints : Hints = Hints( example.Info(List(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)), )  This allows to query Hints for Info using the following syntax: hints.get(example.Info) Regarding the underlyingSchema value in the companion object of IntList, you can see that it is constructed using a list function. Conceptually, it encodes this : &quot;if I'm able to encode or decode an A in a specific format, then I should be able to encode or decode a List[A]&quot;. "},{"title":"Enumerations​","type":1,"pageTitle":"Datatypes and schemas","url":"docs/design/schemas#enumerations","content":"TODO (waiting for smithy 2.0 which changes the syntax) "},{"title":"Extracting Request Information","type":0,"sectionRef":"#","url":"docs/guides/extract-request-info","content":"","keywords":""},{"title":"What is IOLocal?​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#what-is-iolocal","content":"IOLocalis a construct that allows for sharing context across the scope of a Fiber. This means it allows you to get and set some value A in the IOLocal. This value will be accessible across the current Fiber. As a Fiber is forked into new fibers, the value of A is carried over to the new Fiber. However, the new Fiber will not be able to update the value kept on its parent or sibling fibers. This diagram, adapted from the IOLocal docs, illustrates this well:  "},{"title":"Example Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#example-implementation","content":""},{"title":"Smithy Spec​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#smithy-spec","content":"For this example, we are going to be working with the following smithy specification (taken from smithy4s repo): namespace smithy4s.hello use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot; // Indicates that all operations in `HelloWorldService`, // here limited to Hello, can return `GenericServerError`. errors: [GenericServerError], operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person output: Greeting } structure Person { @httpLabel @required name: String } structure Greeting { @required message: String }  See our getting started documentation for instructions on how to use this specification to generate scala code. "},{"title":"Service Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#service-implementation","content":"Let's start by creating a case class that we will use to hold the value of some headers from our request. case class RequestInfo(contentType: String, userAgent: String)  This class will give us a spot to place the Content-Type and User-Agent headers, respectively. These are just shown as an example. We could instead pass any other header or part of the request. From here, we can implement the HelloWorldService interface that smithy4s generated from the specification above. import smithy4s.hello._ import cats.effect.IO import cats.effect.IOLocal final class HelloWorldServiceImpl(requestInfo: IO[RequestInfo]) extends HelloWorldService[IO] { def hello(name: String, town: Option[String]): IO[Greeting] = requestInfo.flatMap { reqInfo: RequestInfo =&gt; IO.println(&quot;REQUEST_INFO: &quot; + reqInfo) .as(Greeting(s&quot;Hello, $name&quot;)) } }  This is a basic implementation that, in addition to returning a Greeting, prints the RequestInfo out to the console. Note that it is getting the RequestInfo from the IO[RequestInfo] that is being passed in as a constructor parameter. This IOwill be created using the sameIOLocalinstance is passed to our middleware implementation. That way, the middleware can set theRequestInfo` value that we are reading here. "},{"title":"Middleware​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#middleware","content":"Below is the middleware implementation. It extracts the Content-Type and User-Agent headers and passes them along in the IOLocalinstance it is provided. import cats.data._ import org.http4s.HttpRoutes import cats.syntax.all._ import org.http4s.headers.{`Content-Type`, `User-Agent`} object Middleware { def withRequestInfo( routes: HttpRoutes[IO], local: IOLocal[Option[RequestInfo]] ): HttpRoutes[IO] = HttpRoutes[IO] { request =&gt; val requestInfo = for { contentType &lt;- request.headers.get[`Content-Type`].map(ct =&gt; s&quot;${ct.mediaType.mainType}/${ct.mediaType.subType}&quot;) userAgent &lt;- request.headers.get[`User-Agent`].map(_.product.toString) } yield RequestInfo( contentType, userAgent ) OptionT.liftF(local.set(requestInfo)) *&gt; routes(request) } }  "},{"title":"Wiring it Together​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#wiring-it-together","content":"Now that we have our service implementation and our middleware, we need to combine them to create our application. import cats.effect.kernel.Resource object Routes { private val docs = smithy4s.http4s.swagger.docs[IO](smithy4s.hello.HelloWorldService) def getAll(local: IOLocal[Option[RequestInfo]]): Resource[IO, HttpRoutes[IO]] = { val getRequestInfo: IO[RequestInfo] = local.get.flatMap { case Some(value) =&gt; IO.pure(value) case None =&gt; IO.raiseError(new IllegalAccessException(&quot;Tried to access the value outside of the lifecycle of an http request&quot;)) } smithy4s.http4s.SimpleRestJsonBuilder .routes(new HelloWorldServiceImpl(getRequestInfo)) .resource .map { routes =&gt; Middleware.withRequestInfo(routes &lt;+&gt; docs, local) } } }  Here we are creating our routes (with swagger docs) and passing them to our middleware. The result of applying the Middleware is our final routes. We also turn our IOLocal into an IO[RequestInfo] for the HelloWorldServiceImpl. We do this because the service implementation does not need to know that the value is coming from an IOLocal or that the value is optional (since it will always be populated by our middleware). Doing it this way allows us to reduce the complexity in the service implementation. Finally, we create our main class and construct the http4s server. import cats.effect.IOApp import com.comcast.ip4s._ import org.http4s.ember.server.EmberServerBuilder object Main extends IOApp.Simple { def run: IO[Unit] = IOLocal(Option.empty[RequestInfo]).flatMap { local =&gt; Routes .getAll(local) .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withHost(host&quot;localhost&quot;) .withPort(port&quot;9000&quot;) .withHttpApp(routes.orNotFound) .build } .useForever } }  Notice that we create the IOLocal with Option.empty[RequestInfo]. This is because IOLocal requires a value to be constructed. However, this value will never be used in practice. This is because we are setting the value in the middleware on every request prior to the request being handled by our HelloWorldService implementation. "},{"title":"Testing it out​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#testing-it-out","content":"With the above in place, we can run our application and test it out. curl -X 'POST' \\ 'http://localhost:9000/Test' \\ -H 'User-Agent: Chrome/103.0.0.0' \\ -H 'Content-Type: application/json'  Running this curl will cause the following to print out to the console: REQUEST_INFO: RequestInfo(Some(application/json),Some(Chrome/103.0.0.0))  "},{"title":"Alternative Methods​","type":1,"pageTitle":"Extracting Request Information","url":"docs/guides/extract-request-info#alternative-methods","content":"If you are working with a tagless F[_] rather than IO directly, you may want to check out Chris Davenport's implementation of FiberLocal. You can also use Kleisli to accomplish the same things we showed in this tutorial and you are welcome to do so if you prefer that. We opted to show an example with IOLocal since it allows users to use IO directly, without monad transformers, which many users will be more comfortable with. Similarly, you could use Local from cats-mtl or probably a variety of other approaches. We recommend you use whatever fits the best with your current application design. "},{"title":"Services and endpoints","type":0,"sectionRef":"#","url":"docs/design/services","content":"","keywords":""},{"title":"The duality of final and initial algebras​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-duality-of-final-and-initial-algebras","content":"Before we dive into the core of the solution, one notion that is drastically helpful is the duality between finally-encoded algebras and initially-encoded algebras. Finally-encoded algebras are object-oriented encodings of a set of operations, just like above : operations are represented as methods in an interface. Interpretation of expressions written in terms of these methods does not involve any runtime transformation from one context to another : the method call is merely executed. In other words, when they are executed, expressions coming from finally-encoded algebras are already in their &quot;final form&quot;. Conversely, initially-encoded algebras represent expressions as data, implying that interpretation involves a transformation of this data into lower level method calls. However, data has the quality of being a first class construct in programming languages, meaning you can pass it around and use it as parameter to functions. This allows for the unification of code-paths, as the differences between some aspects of a bit of logic can be absorbed by the data and handled later on. Finally-encoded KVStore algebra : trait KVStore[Context[_]]{ def put(key: String, value: String) : Context[Unit] def get(key: String) : Context[Option[String]] def delete(key: String) : Context[Unit] }  Initially-encoded KVStore algebra : sealed trait KVStoreOp[Output] object KVStoreOp { case class Put(key: String, value: String) extends KVStore[Unit] case class Get(key: String) extends KVStore[Option[String]] case class Delete(key: String) extends KVStore[Unit] }  These two encodings contain a similar amount of information. It is nearly-trivial to go from a KVstore[Context] instance to a KVStoreOp ~&gt; Context natural transformation, and vice versa: trait ~&gt;[F[_], G[_]]{ def apply[A](fa: F[A]) : G[A] } def asNaturalTransformation[Context[_]](impl: KVStore[Context]) = new (KVStoreOp ~&gt; Context){ def apply[A](fa: KVStoreOp[A]) : Context[A] = fa match { case KVStoreOp.Put(key, value) =&gt; impl.put(key, value) case KVStoreOp.Get(key) =&gt; impl.get(key) case KVStoreOp.Delete(key) =&gt; impl.delete(key) } } def fromNaturalTransformation[Context[_]](run: KVStoreOp ~&gt; Context) = new KVStore[Context]{ def put(key: String, value: String) = run(KVStoreOp.Put(key, value)) def get(key: String) = run(KVStoreOp.Get(key)) def delete(key: String) = run(KVStoreOp.Delete(key)) }  This duality is heavily used by Smithy4s : finally-encoded interfaces are generally more natural to Scala developers, and are better supported in editors (autocompletion, etc). But from an implementation's perspective, the initial, data-based encoding is really interesting, because operations are reified as data-types that can be associated with instances of generic type-classes : it is possible to abstract over data, it is not possible to abstract over method calls. "},{"title":"A detour around kinds​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-detour-around-kinds","content":"The methods generated by Smithy4s are conceptually similar to the methods expressed in the example above, except that the output types are significantly more verbose. trait Interface[Context[_, _, _, _, _,]]{ def operation1(a: A, b: B) : Context[Input, Error, Output, StreamedInput, StreamedOutput] }  Let's address this awkwardness right away, by explaining the rationale behind this seemingly humongous signature : Input​ It's the input type of an operation. Typically, a case class that holds fields matching the method parameters. We keep track of it in the return type for several reasons: In the internal logic of Smithy4s, It prevents having to prematurely shoe-horn kinds into other kinds by means of injection/projection, which helps both implementor and compiler alikeIt will come in handy for the implementation of some pagination-aware interpreters, as pagination typically works by performing a modification of the previous input in order to get the next batch (page) of results. This implies that the input (and therefore its type) must be tracked across several requests resulting from a single method call. Error​ The execution of an operation can result in errors. The Smithy language allows for tying a list of errors to operations. When generating the associated code, Smithy4s synthesize a union. This allows the coproduct of errors associated to an operation to be represented as a bona fide Scala type, which we can abstract over via some type-class instance. This is also very useful for the writing of bi-functor interpreters, for users that are interested in this kind of UX. Output​ No surprise there : this is the data resulting from the run of the operation. StreamedInput, StreamedOutput​ Smithy supports the concept of Streaming. It is communicated as a trait that annotates a single field of the input shape or/and output shape of an operation. Scala does not have a &quot;standard&quot; way of expressing streaming semantics. Moreover, streaming constructs in Scala are heavily context dependant. It is therefore impossible for us to incorporate the concept of &quot;streaming&quot; to our Schema construct as it is meant to be context-free and third-party-free. To get some intuition for why that is : say we want to express streaming using fs2. If we naively generate a case class that has one of its fields annotated with @streaming, it means that the the field is of type fs2.Stream[F, A], which means that we either need to make a decision on what the F is, which is not okay for obvious reasons, or we need to propagate the F[_] type parameter upward to the case class. Now our Schema value, which accompanies the case-class, also have to carry the F ... this propagates throughout the whole codebase. We deemed that not acceptable. Rather than polluting all layers of abstraction, we decided to just have the concept of operation be impacted and hold the streamed type in a separate type parameter. This allows for interpreters from various ecosystem to emerge. It also has the quality of allowing users to access the unary component of outputs (ie, data that is communicated in the headers of HTTP responses) without necessarily allocating resources to consume the streamed component of the output. NB: at the time of writing this, Smithy4s does not have any streaming-aware interpreter implemented. But streaming is such a fundamental notion in remote interactions, and we had to devise a plan to ensure that third parties could decide to implement interpreters without waiting. "},{"title":"Transformation​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#transformation","content":"Because of the complex kinds we're dealing with, we codify a natural-transformation, called Smithy4s.Transformation that allows us to work at this level : trait Transformation[F[_, _, _, _, _], G[_, _, _, _, _]] { def apply[I, E, O, SI, SO](fa: F[I, E, O, SI, SO]): G[I, E, O, SI, SO] }  This is a mouthful, but conceptually, it's exactly the same as our good old polymorphic function typically aliased to ~&gt;. "},{"title":"Codifying the duality between initial and final algebras​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#codifying-the-duality-between-initial-and-final-algebras","content":"What we want users to manipulate is the final-encoded version of a service: a good-old object-oriented interface that has decent editor support. But we need the initial-encoded version to implement interpreters in a generic fashion. So we codify the duality to allow for switching from one to the other via an abstraction called Smithy4s.Service, which is the entry point to all interpreters. trait Service[Final[_[_, _, _, _, _]], Initial[_, _, _, _, _]] { def asTransformation[F[_, _, _, _, _,]](alg: Final[F]) : Transformation[Initial, F] def transform[F[_, _, _, _, _]](transformation: Transformation[Initial, F]) : Final[F] // ... }  Implementations of such interfaces are code-generated. This implies that any smithy Service shape gets translated as a finally-encoded interface, but also as an initially-encoded GADT "},{"title":"The high-level philosophy of Smithy4s​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-high-level-philosophy-of-smithy4s","content":"The goal of Smithy4s is to allow users to derive client stubs and routers in various protocols, by running the generated code (or instances of generated interfaces) in some one-liner functions. To that end, Smithy4s surfaces a number of abstractions (such as smithy4s.schema.Schema) that allow for the implementation of (very) polymorphic interpreters. These interpreters operate on the generated code, which reflects what the user defines in their smithy Specs. The abstractions used by interpreters contain all the elements that allow for turning a high-level method call (from an interface generated by Smithy4s) into a low level request of some sort, and then transform a low level response into the output of the method call. "},{"title":"Logical flow: client-side​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#logical-flow-client-side","content":"Conceptually, to derive a high-level client that uses some sort of Request =&gt; Response protocol, the implementation has to follow a sequence of steps: Assuming this method call : kvstore.get(&quot;key&quot;)turning the method call into a piece of data : KVStoreOp.Get(&quot;key&quot;) using the initially-encoded dual of the KVStore interfaceRetrieving the Smithy4s Schemas (input and output) associated to the Get operationCompiling the schema associated to the input of the Get operation into some encoding function : GetInput =&gt; RequestRunning the request through a low-level Request =&gt; Response function (like an HTTP client)Running Get into some function that gives us its GetInput representationCompiling the schema associated to the output (GetOutput ~= Option[String]) of the Get operation into some decoding function Response =&gt; Output So we get kvstore.get =&gt; KVStoreOp.Get =&gt; GetInput =&gt; Request =&gt; Response =&gt; GetOutput, which gives us the full data flow, client side. "},{"title":"Logical flow: server-side​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#logical-flow-server-side","content":"The server side is different in that we want to derive the Request =&gt; Response function from an instance of our interface (KVStore). The goal is to mechanically translate a request into a method call, and a method's output into a response. The sequence: From a given Request, find the corresponding operation Op (for instance, by means of HTTP path). Let's assume it's the get operation,Retrieve the Smithy4s Schemas (input and output) associated to the operation (KVStoreOp.Get)Compile a Request =&gt; GetInput decoding function, and run the Request through itFrom GetInput, recreate the KVStoreOp.Get instanceFrom KVStoreOp.Get, use the final-encoded dual of KVStoreOp to call the KVStore#get method (implemented by the user). This gets us an GetOutputCompile a GetOutput =&gt; Response encoding function from the schemas, and run the output through it So we get Request =&gt; KVStoreOp.GetInput =&gt; KVStoreOp.Get =&gt; kvstore.get =&gt; GetOutput =&gt; Response, which gives us the full data flow, service side. Both the service-side and client-side logical flows guide the design of the abstractions that are exposed by Smithy4s. "},{"title":"A note about efficiency​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-note-about-efficiency","content":"The flows described above are merely conceptual, and do not account for the optimisations involved to ensure that schemas are not recompiled into codecs on a per-request basis (which would greatly impact performance). Interpreters provided by Smithy4s (HTTP and co) are written to ensure that all compilation is performed ahead of receiving requests, by means of preliminary computations and caching. "},{"title":"The Endpoint abstraction​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#the-endpoint-abstraction","content":"The smithy4s.Endpoint abstraction ties a specific operation to the various schemas that are tied to it. trait Endpoint[Initial[_, _, _, _, _], I, E, O, SI, SO] { def shapeId : ShapeId def hints: Hints def input: Schema[I] def output: Schema[O] def streamedInput: StreamingSchema[SI] def streamedOutput: StreamingSchema[SO] def wrap(input: I): Initial[I, E, O, SI, SO] def errorable: Option[Errorable[E]] }  Endpoints are not type-classes. Instead, the Endpoint trait is extended by the companion object of each member of the GADT forming the initial-encoding of the service interface. So, going back to our KVStore, the corresponding sealed-trait would look like this : sealed trait KVStoreOp[Input, Error, Output, StreamedInput, StreamedOutput]  and the put operation would look like : case class Put(input: PutRequest) extends KVStoreOp[PutRequest, PutError, PutResult, Nothing, Nothing] object Put extends Endpoint[KVStoreOp, PutRequest, PutError, PutResult, Nothing, Nothing] with Errorable[PutError]{ val input = PutRequest.input val output = PutRequest.input val streamedInput = SteamingSchema.nothing val streamedOutput = StreamingSchema.nothing val errorable: Option[Errorable[PutResult]] = this // ... }  "},{"title":"A note on errors​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#a-note-on-errors","content":"As stated previously, Smithy4s generates a coproduct type for each operation, where the members of the coproduct point to the various errors listed in the smithy operation shape. Additionally, each structure annotated with @error in smithy is rendered as a case-class that extends Throwable, because Throwables are the de-facto standard of doing error handling on the JVM. Even libraries that use Either to perform error handling often represent the left-hand-side of the Either as some throwable type, to facilitate the absorption of errors into the error-channels of monadic constructs (IO.raiseError, etc) As a result, it is important for Smithy4s to expose functions that generically enable the filtering of throwables against the Error type parameter of an operation, so that interpreters can intercept errors and apply the correct encoding (dictated via Schema) before communicating them back to the caller over the wire. Conversely, it is important to expose a function that allows to go from the generic Error type parameter to Throwable, so that errors received via low-level communication channels can be turned into Throwable at the client call site, in order to populate the relevant error channel when exposing mono-functor semantics. Therefore, when a smithy operation has errors defined, the corresponding smithy4s.Endpoint also extends the Errorable interface, which looks like this : trait Errorable[E] { def error: UnionSchema[E] def liftError(throwable: Throwable): Option[E] def unliftError(e: E): Throwable }  "},{"title":"Services and endpoints​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#services-and-endpoints","content":"In order to implement any server-side interpreters, it is required to have a list of endpoints. That list is used to implement some matching logic based on the shapeId and/or the hints associated to the endpoints, in order to deterministically decide where to route a low level Request to a specific Endpoint instance. For instance, smithy provides a @http trait out of the box that can annotate operations : service KVStore { operations: [Get, Put] } @http(method: &quot;GET&quot;, uri: &quot;/resource/${key}, code: 200) operation Get { input: GetInput output: GetOutput } structure GetInput { @httpLabel key: String } structure GetOutput { value: String } @http(method: &quot;PUT&quot;, uri: &quot;/resource/${key}, code: 200) operation Put { } structure PutInput { @httpLabel key: String, @httpPayload value: String }  Each @http occurrence get translated to a scala value in the Hints associated to the corresponding endpoint. On server-side, having a list of all the endpoints associated to a service allows for creating a routing logic that dispatches an HTTP Request to the correct endpoint.On client-side, a method call to a service stub gets translated to an instance of the corresponding GADT member. From there, we have to retrieve the schemas associated to the member in question. Additionally, we need to extract the input value out of the member, to run it through an encoder derived from the the associated Schema. Therefore, the Service abstraction needs to be enriched with the following methods : trait Service[Final[_[_, _, _, _, _]], Initial[_, _, _, _, _]] { // ... // useful for server-side def endpoints: List[Endpoint[Initial, _, _, _, _, _]] // useful for client-side def endpoint[I, E, O, SI, SO](op: Initial[I, E, O, SI, SO]): (I, Endpoint[Initial, I, E, O, SI, SO]) }  "},{"title":"Conclusion and complete interfaces​","type":1,"pageTitle":"Services and endpoints","url":"docs/design/services#conclusion-and-complete-interfaces","content":"Here are links to the complete interfaces discussed in this chapter. ServiceEndpoint "},{"title":"Installation (CLI)","type":0,"sectionRef":"#","url":"docs/overview/cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Installation (CLI)","url":"docs/overview/cli#installation","content":"cs install --channel https://disneystreaming.github.io/coursier.json smithy4s  "},{"title":"Usage​","type":1,"pageTitle":"Installation (CLI)","url":"docs/overview/cli#usage","content":"The CLI comes with a number of options to customize output directories, skip openapi generation (or scala generation), provide a filter of allowed namespaces, etc. Use the --help command to get an exhaustive listing. bash&gt; smithy4s --help Usage: smithy4s generate smithy4s dump-model Command line interface for Smithy4s Options and flags: --help Display this help text. Subcommands: generate Generates scala code and openapi-specs from smithy specs dump-model Output a JSON view of the Smithy models  Codegen​ bash&gt; smithy4s generate --help Usage: generate [--output &lt;path&gt;] [--resource-output &lt;path&gt;] [--skip &lt;string&gt;]... [--discover-models] [--allowed-ns &lt;string,string,...&gt;] [--excluded-ns &lt;string,string,...&gt;] [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--localJars &lt;path,path,...&gt;] [&lt;path&gt;...] Generates scala code and openapi-specs from smithy specs Options and flags: --help Display this help text. --output &lt;path&gt;, -o &lt;path&gt; Path where scala code should be generated. Defaults to pwd --resource-output &lt;path&gt; Path where non-scala files should be generated. Defaults to pwd --skip &lt;string&gt; Indicates that some files types should be skipped during generation --discover-models Indicates whether the model assembler should try to discover models in the classpath --allowed-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --excluded-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --localJars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files  Dump model​ bash&gt; smithy4s dump-model --help Usage: dump-model [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--localJars &lt;path,path,...&gt;] [&lt;path&gt;...] Output a JSON view of the Smithy models Options and flags: --help Display this help text. --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --localJars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files  "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/overview/installation","content":"","keywords":""},{"title":"SBT​","type":1,"pageTitle":"Installation","url":"docs/overview/installation#sbt","content":"For mill support, see Mill below. smithy4s-sbt-codegen is a code generating sbt plugin that creates .scala files corresponding to the provided .smithy specs. In project/plugins.sbt: addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.16.3&quot;)  and enable the plugin in the desired sbt module: import smithy4s.codegen.Smithy4sCodegenPlugin val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) // version for smithy4s-core is sourced from Smithy4sCodegenPlugin .settings(libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value)  This will enable the plugin on myModule. We also need to add smithy4s-core here since it is needed for compiling the generated code. By default, the plugin will look in the $MY_MODULE/src/main/smithy directory and will write scala code in $MY_MODULE/target/scala-&lt;version&gt;/src_managed/ when invoking compile. The paths are configurable via the smithy4sInputDir and smithy4sOutputDir settings keys. For example, in order for the plugin to source .smithy specs from ./smithy_input (inside the folder where our build.sbt is) and output the generated files into ./smithy_output. val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( scalaVersion := &quot;2.13.8&quot;, smithy4sInputDir in Compile := (baseDirectory in ThisBuild).value / &quot;smithy_input&quot;, smithy4sOutputDir in Compile := (baseDirectory in ThisBuild).value / &quot;smithy_output&quot;, libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value )  "},{"title":"Mill​","type":1,"pageTitle":"Installation","url":"docs/overview/installation#mill","content":"smithy4s-mill-codegen-plugin is a plugin to enable Smithy4s code generation on a mill module. For example, here, we enabled it on the example module: import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.16.3` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot; ) }  By default, the mill plugin will look for Smithy files under the $MY_MODULE/smithy directory. The generated code ends up in out/$MY_MODULE/smithy4sOutputDir.dest/scala/, again, by default. Code generation happens automatically when you before you compile the module. The paths are configurable via the smithy4sInputDir and smithy4sOutputDir tasks. For example, here we'll read Smithy files from smithy_input and write to smithy_output. import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.16.3` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot; ) override def smithy4sInputDir = T.source { PathRef(T.ctx().workspace / &quot;smithy_input&quot;) } override def smithy4sOutputDir = T { PathRef(T.ctx().workspace / &quot;smithy_output&quot;) } }  "},{"title":"Intro","type":0,"sectionRef":"#","url":"docs/overview/intro","content":"Intro Smithy is an interface definition language (IDL) provided by AWS. It is protocol agnostic, flexible, and reasonably low surface, which facilitates the writing of tooling around it. Smithy4s is a tool that generates third-party-free, protocol-agnostic scala code from smithy specifications. Smithy4s can be used to: quickly derive http/rest servers and clientsderive pure-scala AWS clientsderive CLI toolsand has the potential for much, much more! Smithy4s supports both Smithy 2.0 and Smithy 1.0 models. You can read about the differences in this blogpost from AWS.","keywords":""},{"title":"Sharing specifications","type":0,"sectionRef":"#","url":"docs/overview/sharing-specs","content":"","keywords":""},{"title":"Scala-agnostic context​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#scala-agnostic-context","content":"If you work in a context that is not primordially Scala-centric, you may want to package Smithy specification in Jars to make them easily accessible to various code-generator tools. When that is the case, it is not-advised to use Smithy4s in order to package specifications, as the consuming applications/tools might not have awareness of Scala. The best practice would likely be to have jars that would contain only Smithy files and potentially pure-java custom validators. In order to package Smithy files in jars so that they can be easily consumed by tools, here are the core details: All smithy files should be stored under src/main/resources/META-INF/smithy/ (or in another resource directory, under META-INF/smithy)A manifest file should be stored under that same directoryThe manifest file should reference all the smithy files that can be found in that META-INF/smithy directory.If you are using SBT to do this, consider setting autoScalaLibrary := false. See here for more information.If you are using Mill to do this, consider using a JavaModule instead of a ScalaModule. A couple examples: smithy-aws-apigateway-traitssmithy4s-protocols "},{"title":"Smithy4s-context​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#smithy4s-context","content":"The Smithy4s build-plugins we provide out of the box automatically package the local specifications (used for code-generations) in the resulting jars so that downstream projects (internal and external) can use them. When doing so, Smithy4s abides by the same structure described above. Additionally, Smithy4s will also produce a smithy file containing a piece of metadata listing the namespaces for which code was generated. This way, downstream Smithy4s calls can automatically skip the already-generated namespaces. This does mean two things: Users do not have to manually indicate namespaces that were already generated.When using multi-module builds, Smithy specifications in one module can depend on Smithy specifications in another module it depends on, without the user having to do anything bespoke for it. The resulting Scala code in the downstream module will simply depend on the one in the upstream module, as if it had been handwritten. "},{"title":"Disabling packaging of smithy files in jars​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#disabling-packaging-of-smithy-files-in-jars","content":"If for some reason you want to disable the packaging of Smithy files in the jars created by your build tool, follow the instructions below. SBT​ Add the following setting to your project Compile / smithy4sSmithyLibrary := false  Mill​ Override the following method in your module override def smithy4sSmithyLibrary = T(false)  "},{"title":"Disabling the dependency on smithy files in sibling projects​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#disabling-the-dependency-on-smithy-files-in-sibling-projects","content":"If your project has a multi-module build and some of the modules have the plugin enabled, due to the behavior documented above, dependencies will need to be compiled before code can be generated. Consider the following build (sbt syntax): val a = project val b = project.enablePlugin(Smithy4sCodegenPlugin).dependsOn(a)  Whenever you want to generate the Scala code in project b, your build tool will trigger compilation of a. This happens so that the Smithy files in the a project get packaged into a JAR file - just like they normally are when you package the a project otherwise (for publishLocal, stage etc.). You can opt out of this behavior: SBT​ val b = project.settings( Compile / smithy4sLocalJars := Nil )//...  Mill​ object b extends Smithy4sModule { //... override def smithy4sLocalJars = List.empty[PathRef] }  This will not only remove the need for compilation (for the purposes of codegen), but also remove any visibility of the Smithy files in the local dependencies of your project (local meaning they're defined in the same build). You can use the same setting, smithy4sLocalJars, to add additional JARs containing Smithy specs - just keep in mind that remote dependencies (libraryDependencies) are added automatically! "},{"title":"A word of warning​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#a-word-of-warning","content":"Smithy4s optimises for &quot;correctness&quot; as opposed to &quot;compatibility.&quot; This means the generated Scala code aims at 1) being an accurate reflection of the Smithy models and 2) providing an idiomatic developer experience. This happens at the cost of a lack of guarantees around the binary compatibility of the generated code when the Schema evolves. When packaging Smithy specs in artifacts that contain Smithy4s-generated code, developers should keep that aspect in mind, and ensure that the version of Smithy4s that produced upstream artifacts is binary-compatible with the version that they use locally. Tools such as MiMa can help We cannot recommend treating Smithy4s-generated code as publishable library-material. Should you decide to do so, please exercise caution. Depending on shared specifications "},{"title":"Artifacts containing only specifications​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#artifacts-containing-only-specifications","content":"For instance, AWS publishes a number of api-gateway specific traits to Maven central (the shapes are defined there in a smithy-compliant Json file). "},{"title":"SBT​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#sbt-2","content":"Using the SBT plugin, the Smithy4s config object can be used to tag dependencies that Smithy4s should feed to the code generator. You can declare your intent to depend on these smithy definitions as such: libraryDependencies += &quot;software.amazon.smithy&quot; % &quot;smithy-aws-iam-traits&quot; % &quot;1.14.1&quot; % Smithy4s  "},{"title":"Mill​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#mill-2","content":"Mill uses a separate task to define dependencies that the code-generator should have awareness of: def smithy4sIvyDeps = Agg(ivy&quot;software.amazon.smithy::smithy-aws-iam-traits:1.14.1&quot;)  "},{"title":"Consequence​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#consequence","content":"This will have the effect of loading the contents of the smithy files (or smithy-compliant Json files) from the artifact into the aggregated model that Smithy4s uses as an input to the code generator. It means that the traits and shapes defined in these files will be available to use in your models, but it also means that Smithy4s will try to generate code for these shapes. This artifact will not be included as a dependency to your project at compile-time (nor runtime), it will only be consumed for the Smithy specs (and validators) it may contain. "},{"title":"Artifacts containing both Smithy files and Smithy4s generated code​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#artifacts-containing-both-smithy-files-and-smithy4s-generated-code","content":"When using Smithy4s, you may want to depend on artifacts that may have been built using Smithy4s, containing both Smithy specifications and generated Scala code (or rather, JVM bytecode resulting from the compilation of generated Scala code). In this case, you have to tell your build tool that a dependency should be used both by Smithy4s at codegen-time, and by the Scala compiler at compile time. This is achieved by doing the following "},{"title":"SBT​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#sbt-3","content":"libraryDependencies += &quot;organisation&quot; % &quot;artifact&quot; % &quot;version&quot; % Smithy4sCompile  Which is merely a shortcut for: libraryDependencies += &quot;organisation&quot; % &quot;artifact&quot; % &quot;version&quot; % &quot;smithy4s,compile&quot;  "},{"title":"Mill​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#mill-3","content":" def compileAndCodegenDeps = T(Agg(ivy&quot;organisation:artifact:version&quot;)) def ivyDeps = T(super.ivyDeps() ++ compileAndCodegenDeps()) def smithy4sIvyDeps = T(super.smithy4sIvyDeps() ++ compileAndCodegenDeps())  "},{"title":"Consequence​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#consequence-1","content":"Because the upstream usage of Smithy4s will have resulted in the creation of metadata tracking the namespaces that were already generated, the &quot;local&quot; Smithy4s code-generation will automatically skip the generation of code that should not be generated again. "},{"title":"Manually skipping (or including) namespaces during code-generation.​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#manually-skipping-or-including-namespaces-during-code-generation","content":"Sometimes, you may want to tell Smithy4s to skip code-generation of some namespaces altogether, because the corresponding code may have been produced by another tool than Smithy4s. In that case, you can gain control over which namespaces Smithy4s crawls through when performing the code generation to avoid regenerating code that already exists. This is achieved via a couple of build-settings (the names are shared between SBT and Mill). smithy4sAllowedNamespaces which is an allow-listsmithy4sExcludedNamespaces which is a disallow-list By default, Smithy4s tries to generate everything but shapes that are in the following namespaces: smithy4s.apismithy4s.metanamespaces that start with awsnamespaces that start with smithy "},{"title":"Note regarding credentials​","type":1,"pageTitle":"Sharing specifications","url":"docs/overview/sharing-specs#note-regarding-credentials","content":"The SBT plugin provided by Smithy4s uses SBT's resolution mechanism (based on coursier) to retrieve the artifacts from their respective repositories. This implies that the resolvers-related settings are respected, included credentials that may be needed to read from some private artifact repository. In the CLI, the mechanisms native to coursier are respected. "},{"title":"Quick Start","type":0,"sectionRef":"#","url":"docs/overview/quickstart","content":"","keywords":""},{"title":"For sbt​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#for-sbt","content":"This section will get you started with a simple sbt module that enables smithy4s code generation. For a similar setup for mill, see Mill below. "},{"title":"project/plugins.sbt​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#projectpluginssbt","content":"Add the smithy4s-sbt-codegen plugin to your build. addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.16.3&quot;)  "},{"title":"build.sbt​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#buildsbt","content":"Enable the plugin in your project, add the smithy and http4s dependencies. import smithy4s.codegen.Smithy4sCodegenPlugin ThisBuild / scalaVersion := &quot;2.13.8&quot; val example = project .in(file(&quot;modules/example&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( libraryDependencies ++= Seq( &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s&quot; % smithy4sVersion.value, &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s-swagger&quot; % smithy4sVersion.value, &quot;org.http4s&quot; %% &quot;http4s-ember-server&quot; % &quot;0.23.16&quot; ) )  "},{"title":"For Mill​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#for-mill","content":"This section will get you started with a mill module with code generation enabled on it. In your build.sc: import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.16.3` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot;, ivy&quot;com.disneystreaming.smithy4s::smithy4s-http4s-swagger:${smithy4sVersion()}&quot;, ivy&quot;org.http4s::http4s-ember-server:0.23.16&quot; ) }  "},{"title":"Smithy content​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#smithy-content","content":"Now is the time to add some Smithy shapes to see what code generation can do for you. Following the setup above, the location for the Smithy content will change depending on what build tool you used. Now let's define an API in Smithy. Create the following file: for sbt, you'll write in modules/example/src/main/smithy/ExampleService.smithy.for mill, you'll write in example/smithy/ExampleService.smithy And add the content below: namespace smithy4s.hello use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String }  The Scala code corresponding to this smithy file will be generated the next time you compile your project. "},{"title":"Using the generated code​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#using-the-generated-code","content":"Now, let's use the generated code by the service. You need to create a scala file at the following location: for sbt modules/example/src/main/scala/Main.scalafor mill example/src/Main.scala Implement your service by extending the generated Service trait. Wire up routes into server. import smithy4s.hello._ import cats.effect._ import cats.implicits._ import org.http4s.implicits._ import org.http4s.ember.server._ import org.http4s._ import com.comcast.ip4s._ import smithy4s.http4s.SimpleRestJsonBuilder object HelloWorldImpl extends HelloWorldService[IO] { def hello(name: String, town: Option[String]) : IO[Greeting] = IO.pure { town match { case None =&gt; Greeting(s&quot;Hello $name!&quot;) case Some(t) =&gt; Greeting(s&quot;Hello $name from $t!&quot;) } } } object Routes { private val example: Resource[IO, HttpRoutes[IO]] = SimpleRestJsonBuilder.routes(HelloWorldImpl).resource private val docs: HttpRoutes[IO] = smithy4s.http4s.swagger.docs[IO](HelloWorldService) val all: Resource[IO, HttpRoutes[IO]] = example.map(_ &lt;+&gt; docs) } object Main extends IOApp.Simple { val run = Routes.all .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build } .use(_ =&gt; IO.never) }  "},{"title":"Run Service​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#run-service","content":"for sbt: sbt &quot;example/run&quot;for mill: mill example.run "},{"title":"Navigate to localhost:9000/docs​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#navigate-to-localhost9000docs","content":"Here you will find the automatically generated SwaggerUI which will allow you to easily test your API.   "},{"title":"Client Example​","type":1,"pageTitle":"Quick Start","url":"docs/overview/quickstart#client-example","content":"You can also generate a client using smithy4s. import org.http4s.ember.client.EmberClientBuilder object ClientImpl extends IOApp.Simple { val helloWorldClient: Resource[IO, HelloWorldService[IO]] = for { client &lt;- EmberClientBuilder.default[IO].build helloClient &lt;- SimpleRestJsonBuilder(HelloWorldService) .client(client) .uri(Uri.unsafeFromString(&quot;http://localhost:9000&quot;)) .resource } yield helloClient val run = helloWorldClient.use(c =&gt; c.hello(&quot;Sam&quot;, Some(&quot;New York City&quot;)) .flatMap(greeting =&gt; IO.println(greeting.message)) ) }  "},{"title":"aws","type":0,"sectionRef":"#","url":"docs/protocols/aws/aws","content":"aws WARNING: THIS IS EXPERIMENTAL, DO NOT NOT EXPECT PRODUCTION READINESS Smithy4s provides functions to create AWS clients from generated code. At the time of writing this, smithy4s is only able to derive clients for AWS services that use the AWS Json 1.0/1.1 protocol. The AWS smithy specs (that are written in json syntax) can be found in some of the official SDKs published by AWS. These .json files can be understood by smithy4s, just like .smithy, and can be used to generate code. Just copy/paste them in your project. We (the Smithy4s maintainers) do not intend to publish pre-generated artifacts containing the AWS clients, there's a lot of nuance there and maintainance burden that we do not have the capacity to assume. In particular, backward binary compatibility of the generated code is impossible to guarantee at this time. Setup​ In build.sbt libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-aws-http4s&quot; % smithy4sVersion.value ) In your Scala code: import cats.effect._ import org.http4s.ember.client.EmberClientBuilder import smithy4s.aws._ // AWS models and cats-effect/fs2 specific functions // AWS models and cats-effect/fs2 specific functions import smithy4s.aws.http4s._ // AWS/http4s specific integration // AWS/http4s specific integration import com.amazonaws.dynamodb._ // Generated code from specs. // Generated code from specs. object Main extends IOApp.Simple { def run = resource.use { dynamodb =&gt; dynamodb .describeTable(TableName(&quot;omelois-test&quot;)) .run .flatMap(IO.println(_)) } val resource: Resource[IO, AwsClient[DynamoDBGen, IO]] = for { httpClient &lt;- EmberClientBuilder.default[IO].build dynamodb &lt;- DynamoDB.awsClient(httpClient, AwsRegion.US_EAST_1) } yield dynamodb } ","keywords":""},{"title":"Compliance Tests","type":0,"sectionRef":"#","url":"docs/protocols/compliance-tests","content":"","keywords":""},{"title":"Example specification​","type":1,"pageTitle":"Compliance Tests","url":"docs/protocols/compliance-tests#example-specification","content":"$version: &quot;2&quot; namespace smithy4s.hello use smithy4s.api#simpleRestJson use smithy.test#httpRequestTests @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @httpRequestTests([ { id: &quot;hello-success&quot; protocol: simpleRestJson method: &quot;POST&quot; uri: &quot;/World&quot; params: { name: &quot;World&quot; } }, { id: &quot;hello-fails&quot; protocol: simpleRestJson method: &quot;POST&quot; uri: &quot;/fail&quot; params: { name: &quot;World&quot; } } ]) @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input := { @httpLabel @required name: String }, output := { @required message: String } }  We have a very simple specification: one operation with basic input and output shapes. We've added a httpRequestTests to define a compliance test for protocol implementors. "},{"title":"Testing the protocol​","type":1,"pageTitle":"Compliance Tests","url":"docs/protocols/compliance-tests#testing-the-protocol","content":"The service in the specification is annotated with the simpleRestJson protocol definition. We'll use the compliance-tests module to make sure this protocol can handle such an operation. Note: the following code and the compliance-tests module do not depend on a specific test frameworks. If you want to hook it into your test framework, it is easy to do so but it's outside the scope of this document. Refer to this example to see how we did it for Weaver in this project. First, some imports and an implicit CompatEffect that is required because we support both cats-effect 2 and 3. import cats.effect._ import org.http4s._ import org.http4s.client.Client import smithy4s.compliancetests._ import smithy4s.example._ import smithy4s.http4s._  Then, you can create and instance of ClientHttpComplianceTestCase while selecting the protocol to use and the service to test: val testGenerator = new ClientHttpComplianceTestCase[ smithy4s.api.SimpleRestJson, HelloWorldServiceGen, HelloWorldServiceOperation ]( smithy4s.api.SimpleRestJson() ) { import org.http4s.implicits._ private val baseUri = uri&quot;http://localhost/&quot; def getClient(app: HttpApp[IO]): Resource[IO, HelloWorldService[IO]] = SimpleRestJsonBuilder(HelloWorldServiceGen) .client(Client.fromHttpApp(app)) .uri(baseUri) .resource } val tests: List[ComplianceTest[IO]] = testGenerator.allClientTests()  Now, you can iterate over the test cases and do what you want. This is where you would hook in the test framework of your choice, but in the following example, we're just going to print the result: import cats.syntax.traverse._ import cats.effect.unsafe.implicits.global val runTests: IO[List[String]] = tests .map { tc =&gt; tc.run.map { case Left(value) =&gt; s&quot;Failed ${tc.name} with the following message: $value&quot; case Right(_) =&gt; s&quot;Success ${tc.name}&quot; } } .sequence  Will produce the following when executed: Success smithy4s.example#Hello(client|request): helloSuccess Failed smithy4s.example#Hello(client|request): helloFails with the following message: Actual value: http://localhost/World was not equal to http://localhost/fail.  "},{"title":"Protocols and Smithy4s","type":0,"sectionRef":"#","url":"docs/protocols/protocols","content":"Protocols and Smithy4s The code generated by Smithy4s is strictly protocol agnostic, meaning that there is no particular processing to handle HTTP semantics, or JSON semantics in the generated code. Instead, Smithy4s relies on a number of highly polymorphic interfaces to communicate with the generated code, and derive JSON codecs out of it, or turn high level user provided code into HTTP services. But in theory, the same generated code can be used conjointly with other serialisation technologies (protobuf for instance) and protocols (gRPC). Protocol specific &quot;hints&quot; (called traits)can be added to the smithy models. Smithy4s accurately renders corresponding values, and allows for their retrieval via the polymorphic interfaces. This is how HTTP semantics can be derived from the generated code, for instance. Smithy4s is also not tied to any third-party library, and users could provide integrations with existing libraries on their own side, or come up with new interesting usecases. However, Smithy4s provides a few out-of-the-box integrations that are described in this section.","keywords":""},{"title":"Deriving CLIs","type":0,"sectionRef":"#","url":"docs/protocols/deriving-cli","content":"Deriving CLIs The Smithy4s Decline module provides the capability to derive a Decline Cli for your service.The cli generated will be in the form of a Command[F[Unit]] where F is the effect type of your service.This module is written in Tagless Final style and requires an F[] for which there is an instance of cats.MonadThrow Let's revisit our HelloWorld smithy definition from the Quickstart namespace smithy4s.hello use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String } Lets implement the HelloWorld service , we will use cats.effect.IO for our effect type. import smithy4s.hello._ import cats.effect.IO object HelloWorldServiceInstance{ val simple = new HelloWorldService[IO]{ def hello(name: String, town: Option[String]):IO[Greeting] = { IO{ Greeting(s&quot;hello $name , who hails from $town&quot;) } } } } Now Using the decline module from Smithy4s we can wrap the service instance in an instance of a Smithy4sCli. The Smithy4sCli allows the customization of the Opts and stdin/stdout/stderr handling There is a convenient helper method Smithy4sCli.standalone to make it easier to construct Cli's using defaults.To utilize the helper method, wrap the service in an instance of Opts and pass it into Smithy4sCli.standalonethere are 2 methods available on the Smithy4sCli instance opts which will provide an Opts[F[Unit]] for the servicecommand which will provide a Command[F[Unit]] for the service. This uses defaults from the Smithy spec command name will use the service name if documentation comments are available on the service , they will be used as the command help text import com.monovore.decline._ import smithy4s.decline.Smithy4sCli val serviceWrappedInOpts = Opts(HelloWorldServiceInstance.simple) val helloCommand: Command[IO[Unit]] = Smithy4sCli.standalone(serviceWrappedInOpts).command helloCommand is now a runnable Command that can parse command line args and returns an IO[Unit]We can implement a CLI that will run the command and print the result to stdout import smithy4s.decline.Smithy4sCli import cats.effect._ import com.monovore.decline._ import com.monovore.decline.effect.CommandIOApp object app extends IOApp { override def run(args: List[String]) = { val helloCommand: Command[IO[ExitCode]] = Smithy4sCli .standalone(Opts(HelloWorldServiceInstance.simple)) .command.map(_.redeem(_ =&gt; ExitCode.Error, _ =&gt; ExitCode.Success)) CommandIOApp.run(helloCommand, args) } } the command will provide the following interface Usage: hello-world-service hello [--output &lt;output&gt;] &lt;name&gt; [&lt;town&gt;] HTTP POST /{name} Options and flags: --help Display this help text. --output &lt;output&gt; Output mode Smithy to Decline mappings The Service name will be used to generate the top level Command All operations will be mapped to subcommands The Input structure is flattened to top level fields with no nesting All Primitives are mapped to a Positional decline Argument , with the following exceptions. Boolean fields are mapped to a decline FlagBlobs are mapped to take in either stdin(by passing in - ) or a full file path and will produce a Byte array Timestamps are parsed using TimestampFormat.DATE_TIME by default, but @timestampFormat can be used to customize that. Lists and recursive types a top level list is converted to a repeated positional argument (or flag in case of Boolean)All recursive types expect json to be passed in. How is Nesting handled all nested fields are converted to Options a nested list is converted to expect a json i.e. List[String] would expect '[&quot;foo&quot;,&quot;baz&quot;,&quot;qux&quot;]' as a decline Option when the nested list contains blobs , it will expect a json of base64 encoded strings Help Documentation is added to every field, operation and service - if available. For HTTP operations a path template is provided as well. Missing Features Collision Handling for un-nesting of nested fields","keywords":""},{"title":"SimpleRestJson client","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/client","content":"SimpleRestJson client The smithy4s-http4s module provides functions that transform low-level http4s clients into high-level stubs, provided the corresponding service definitions (in smithy) are annotated with the simpleRestJson protocol. Uri is optional as it will default to http://localhost:8080 In build.sbt libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s&quot; % smithy4sVersion.value ) In Clients.scala import smithy4s.http4s._ import org.http4s.Uri import org.http4s.client.Client import cats.effect.IO import cats.effect.Resource // the package under which the scala code was generated import smithy4s.hello._ object Clients { def helloWorldClient(http4sClient: Client[IO]) : Resource[IO, HelloWorldService[IO]] = HelloWorldService.simpleRestJson .client(http4sClient) .uri(Uri.unsafeFromString(&quot;http://localhost&quot;)) .resource // alternatively ... def helloWorldClient2(http4sClient: Client[IO]) : Resource[IO, HelloWorldService[IO]] = SimpleRestJsonBuilder(HelloWorldService) .client(http4sClient) .uri(Uri.unsafeFromString(&quot;http://localhost&quot;)) .resource } ","keywords":""},{"title":"The SimpleRestJson protocol","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/overview","content":"","keywords":""},{"title":"Semantics​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#semantics","content":"In this protocol, the values in shapes are bound to http metadata or body according to the specification of the Http Binding traits. However, the @mediaType trait has no incidence, and all bodies (when present) are serialised in JSON. "},{"title":"Example spec​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#example-spec","content":"namespace smithy4s.example use smithy4s.api#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot; // Indicates that all operations in `HelloWorldService`, // here limited to the Hello operation, can return `GenericServerError`. errors: [GenericServerError] operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person output: Greeting } structure Person { @httpLabel @required name: String @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String }  "},{"title":"Supported traits​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#supported-traits","content":"This protocol and its interpreters, are aware of the following traits provided out of the box: all simple shapescomposite data shapes, including collections, unions, structures.operations and servicesenumerationserror traithttp traits, including http, httpError, httpLabel, httpHeader, httpPayload, httpQuery, httpPrefixHeaders, httpQueryParams.timestampFormat trait "},{"title":"Decoding and encoding unions​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"docs/protocols/simple-rest-json/overview#decoding-and-encoding-unions","content":"The SimpleRestJson protocol supports 3 different union encodings : tagged (default)untaggeddiscriminated See the section about unions for a detailed description. "},{"title":"Openapi","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/openapi","content":"","keywords":""},{"title":"Swagger UI​","type":1,"pageTitle":"Openapi","url":"docs/protocols/simple-rest-json/openapi#swagger-ui","content":"When you visit your documentation page, you'll be served with a Swagger UI application that looks like this:  If your documentation route supports multiple service, the dropdown in the top bar (top right) should allow you to select other specifications:  "},{"title":"Editor Support","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/editor-support","content":"Editor Support Disney Streaming develops and maintains a Smithy language server, that implements features such as jump-to-definition, auto-completion, validation diagnostics. We also provide a VS Code extension that talks to the language server, and provides a smooth developer experience.","keywords":""},{"title":"SimpleRestJson server","type":0,"sectionRef":"#","url":"docs/protocols/simple-rest-json/server","content":"","keywords":""},{"title":"A note about errors​","type":1,"pageTitle":"SimpleRestJson server","url":"docs/protocols/simple-rest-json/server#a-note-about-errors","content":"When encountering data types annotated with the @error trait in smithy, smithy4s will ensure that the generated types extend Throwable. The interpreters are aware of it, and try to recover any error raised in your effect-types that your smithy specs know about, in order to render it correctly in Json and apply the specified status code (see the @httpError trait for this). As a convenience, Smithy4s provides mapErrors and flatMapErrors methods, that allow to intercept exceptions that were not specified in the spec, and transform them into exceptions that were. In particular, the smithy4s interpreters raise specific errors when they fail to decode http requests. The mapErrors and flatMapErrors methods can be used to ensure that a specified error is returned by your service: myRoutes.mapErrors{ case e : PayloadError =&gt; MyClientError(...) }.resource  "},{"title":"Wiring the routes​","type":1,"pageTitle":"SimpleRestJson server","url":"docs/protocols/simple-rest-json/server#wiring-the-routes","content":"As a reminder, to wire those routes into a server, you need something like: import cats.effect._ import org.http4s.ember.server._ import org.http4s.implicits._ import com.comcast.ip4s._ object Main extends IOApp { def run(args: List[String]): IO[ExitCode] = Routes.myRoutes.flatMap { routes =&gt; EmberServerBuilder.default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build }.use(_ =&gt; IO.never) .as(ExitCode.Success) }  "},{"title":"Smithy traits","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/traits","content":"","keywords":""},{"title":"Creating your own traits​","type":1,"pageTitle":"Smithy traits","url":"docs/the-smithy-idl/traits#creating-your-own-traits","content":"Smithy makes it really easy to create your own traits: namespace foo @trait(selector: is(structure)) string customThing @customThing(&quot;hello&quot;) structure MyStructure { }  "},{"title":"Regarding Smithy4s handling of traits​","type":1,"pageTitle":"Smithy traits","url":"docs/the-smithy-idl/traits#regarding-smithy4s-handling-of-traits","content":"Smithy4s automatically creates corresponding values in the generated Scala code, for all the annotations it finds, whether defined in the smithy prelude, or defined by users. These values can be retrieved via some interfaces that will be documented in a near future. "},{"title":"The Smithy IDL","type":0,"sectionRef":"#","url":"docs/the-smithy-idl/smithy-idl","content":"","keywords":""},{"title":"The smithy metamodel​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#the-smithy-metamodel","content":"In this section, we'll list various available shapes that let you define data and operations in smithy, and how they translate in the Scala code generated by Smithy4s. "},{"title":"Primitive types​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#primitive-types","content":"Smithy provides the following &quot;primitive&quot; types out of the box. BooleanStringIntegerLongFloatShortDoubleByteBigIntegerBigDecimalBlob (smithy4s.ByteArray, wrapper to Array[Byte])Timestamp (smithy4s.Timestamp, translated from/to java or javascript time types)Document (smithy4s.Document, a bespoke Json ADT) "},{"title":"Named primitives​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#named-primitives","content":"Smithy lets you define custom names for primitive types: namespace foo integer Age long Identifier  These get translated as unboxed type wrappers, or newtypes, that look like a case class but do not induce any boxing at runtime. "},{"title":"Collection types​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#collection-types","content":"Smithy provides 3 different shapes of collections: lists, sets, and maps. They translate to the corresponding scala.collection types in the generated Scala code. namespace foo list IntList { member: Integer } set StringSet { member: Set } // At this time, only string shapes can be used as keys to map. map AgeMap { key: String value: Integer }  "},{"title":"Enums​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#enums","content":"Smithy supports two types of enums, for string and integers : enum FooBar { FOO = &quot;foo&quot; BAR = &quot;bar&quot; } intEnum FaceCard { JACK = 1 QUEEN = 2 KING = 3 ACE = 4 JOKER = 5 }  "},{"title":"Structures​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#structures","content":"Structures are product types. In Scala, they naturally translate to case classes. namespace foo structure Person { @required firstName: String @required lastName: String dateOfBirth: Timestamp }  "},{"title":"Unions​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#unions","content":"Unions are coproduct types. In Scala, they quite naturally translate to sealed traits. Union members can target any data shape, be it a structure or a primitive type. namespace foo structure Cat { name: String } structure Dog { name: String } union Animal { cat: Cat dog: Dog }  "},{"title":"Operations and services​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#operations-and-services","content":"Operations​ Operations are essentially an optional Input, an optional Output, and an optional list of errors. Inputs, outputs and errors all have to be structure shapes. namespace foo operation Greet { input: GreetInput output: GreetOutput errors: [BadInput] } structure GreetInput { name: String } structure GreetOutput { message: String } @error(&quot;client&quot;) structure BadInput { message: String }  Errors​ Regarding errors, smithy4s translates them as case classes extending Throwable. The getMessage method of the throwable is implemented in terms of the following (based on the first match): a field annotated with the @errorMessage traita field named message Services​ Services are basically a list of operations, and an optional list of errors. namespace foo service HelloService { operations: [Greet] errors: [ServerError] } @error(&quot;server&quot;) structure ServerError { message: String }  Smithy4s translates them in the following fashion: package object foo { type HelloService[F[_]] = HelloServiceGen[???] }  HelloService is type alias that exposes a normal &quot;functor-shaped&quot; type parameter: we are aware that the most common usecase of Smithy4s abides by the &quot;capatibility trait&quot; pattern (or tagless-final), against effect types that probably abide by the cats-effect semantics. However, the actual interface is HelloServiceGen, which has a higher degree of polymorphism. It looks like this: package foo trait HelloServiceGen[P[_, _, _, _, _]]{ def greet(name: String) : P[GreetInput, Greet.Error, GreetOutput, Nothing, Nothing] }  P represents an abstract context against which operations are going to run. The abstract context has 5 type parameters: inputerroroutputstreamed input (Nothing, most of the time)streamed output (Nothing, most of the time) Keeping track of these parameters is really important for the implementation intepreters. It also opens the door for providing interpreters that work against bi-functors (EitherT[IO, *, *]) without changing the generated code. "},{"title":"Currently not supported (in particular)​","type":1,"pageTitle":"The Smithy IDL","url":"docs/the-smithy-idl/smithy-idl#currently-not-supported-in-particular","content":"Smithy has a resource type of shape, that represents CRUD specialised services. It is currently not supported in Smithy4s. "}]